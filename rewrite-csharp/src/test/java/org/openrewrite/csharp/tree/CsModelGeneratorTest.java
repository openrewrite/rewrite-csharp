/*
 * Copyright 2025 the original author or authors.
 * <p>
 * Licensed under the Moderne Source Available License (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * https://docs.moderne.io/licensing/moderne-source-available-license
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.openrewrite.csharp.tree;

import org.jspecify.annotations.Nullable;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.condition.EnabledIfSystemProperty;
import org.openrewrite.*;
import org.openrewrite.csharp.CSharpPrinter;
import org.openrewrite.internal.ListUtils;
import org.openrewrite.java.JavaParser;
import org.openrewrite.java.JavaTemplate;
import org.openrewrite.java.JavaVisitor;
import org.openrewrite.java.format.AutoFormatVisitor;
import org.openrewrite.java.format.MinimumViableSpacingVisitor;
import org.openrewrite.java.format.NormalizeFormatVisitor;
import org.openrewrite.java.tree.*;
import org.openrewrite.marker.Markers;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@EnabledIfSystemProperty(named = "runManualTests", matches = "true")
public class CsModelGeneratorTest {

    @Test
    public void generateCsModel() throws IOException {
        Path csJavaPath = Paths.get("src/main/java/org/openrewrite/csharp/tree/Cs.java");
        Path csModelPath = Paths.get("src/main/java/org/openrewrite/csharp/tree/CsModel.java");
        Path csModel2Path = Paths.get("../Rewrite/src/Rewrite.CSharp/CSharp/CsModel.g.cs");

        String csJavaSource = Files.readString(csJavaPath);

        JavaParser javaParser = JavaParser.fromJavaVersion()
          .classpath(JavaParser.runtimeClasspath())
          .build();

        ExecutionContext ctx = new InMemoryExecutionContext();

        J.CompilationUnit cu = javaParser.parse(csJavaSource)
          .findFirst()
          .map(J.CompilationUnit.class::cast)
          .orElseThrow(() -> new IllegalStateException("Failed to parse Cs.java"));

        // Transform the compilation unit
        J.CompilationUnit transformed = (J.CompilationUnit) new CsModelTransformer().visitNonNull(cu, ctx);

        // Write the transformed file
        String output = transformed.print();

        // Post-process to fix @Nullable placement for Cs.Something types
//        output = fixNullableAnnotationInOutput(output);


//        Files.writeString(csModelPath, output);
//
//        System.out.println("Successfully generated CsModel.java");
        transformed = (J.CompilationUnit)new AutoFormatVisitor<>().visitNonNull(transformed, ctx, new Cursor(null, transformed));

        transformed = (J.CompilationUnit) new JavaToCsharpTransformer().visitNonNull(transformed, ctx);

        transformed = (J.CompilationUnit)new AutoFormatVisitor<>().visitNonNull(transformed, ctx, new Cursor(null, transformed));
        var csPrinter = new CSharpPrinter<Integer>();
        var printOutput = new PrintOutputCapture<Integer>(0);
        csPrinter.visit(transformed, printOutput);
        output = printOutput.getOut();

        var autoGeneratedHeader = """
          //------------------------------------------------------------------------------
          // <auto-generated>
          //     Changes to this file may cause incorrect behavior and will be lost if
          //     the code is regenerated.
          // </auto-generated>
          //------------------------------------------------------------------------------
          #pragma warning disable CS0108, CS0114
          #pragma warning disable CS0169 // Field is never used
          #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider adding the 'required' modifier or declaring as nullable.
          #nullable enable
          """;
        output = autoGeneratedHeader + "\n" + output;
        Files.writeString(csModel2Path, output);

    }


    private static class CsModelTransformer extends JavaVisitor<ExecutionContext> {

        private boolean isTopLevelInterface = true;
        private int nestingLevel = 0;

        @Override
        public J.CompilationUnit visitCompilationUnit(J.CompilationUnit cu, ExecutionContext ctx) {
            return (J.CompilationUnit) super.visitCompilationUnit(cu, ctx);
        }

        @Override
        public  J.@Nullable ClassDeclaration visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext ctx) {
            String className = classDecl.getSimpleName();

            // Skip Padding classes entirely
            if ("Padding".equals(className)) {
                return null;
            }

            // Track nesting level
            nestingLevel++;

            // Change interface name from Cs to CsModel for the top-level interface
            if (isTopLevelInterface && classDecl.getKind() == J.ClassDeclaration.Kind.Type.Interface &&
              "Cs".equals(className)) {
                classDecl = classDecl.withName(classDecl.getName().withSimpleName("CsModel"));
                isTopLevelInterface = false;
            }

            // Process implements clause for classes
            classDecl = processImplementsClause(classDecl);


            // strip out all annotations
            classDecl = classDecl.withLeadingAnnotations(new ArrayList<>());

            // Remove all methods from the body
            if (classDecl.getBody() != null) {
                List<Statement> filteredStatements = classDecl.getBody().getStatements().stream()
                  .filter(stmt -> {
                      if (stmt instanceof J.MethodDeclaration) {
                          return false;
                      }
                      if (stmt instanceof J.ClassDeclaration) {
                          J.ClassDeclaration innerClass = (J.ClassDeclaration) stmt;
                          // Keep non-Padding classes
                          return !"Padding".equals(innerClass.getSimpleName());
                      }
                      return true;
                  })
                  .map(stmt -> (Statement) stmt.accept(this, ctx))
                  .filter(Objects::nonNull)
                  .collect(Collectors.toList());

                classDecl = classDecl.withBody(classDecl.getBody().withStatements(filteredStatements));
            }

            nestingLevel--;
            return classDecl;
        }

        private J.ClassDeclaration processImplementsClause(J.ClassDeclaration classDecl) {
            List<TypeTree> implementsList = classDecl.getImplements();
            if (implementsList == null || implementsList.isEmpty()) {
                return classDecl;
            }

            // Collect interfaces other than Cs
            List<String> otherInterfaces = new ArrayList<>();
            for (TypeTree impl : implementsList) {
                String implName = getTypeName(impl);
                if (!"Cs".equals(implName) && !"CsModel".equals(implName)) {
                    otherInterfaces.add(implName);
                }
            }

            // Clear implements list
            classDecl = classDecl.withImplements(null);

            // Add @Implements annotation if there are other interfaces
            if (!otherInterfaces.isEmpty()) {
                String annotationValue = otherInterfaces.stream()
                  .map(i -> "\"" + i + "\"")
                  .collect(Collectors.joining(", "));

                if (otherInterfaces.size() == 1) {
                    annotationValue = "\"" + otherInterfaces.get(0) + "\"";
                } else {
                    annotationValue = "{" + annotationValue + "}";
                }

                J.Annotation implementsAnnotation = new J.Annotation(
                  Tree.randomId(),
                  Space.format("\n    "),
                  Markers.EMPTY,
                  new J.Identifier(Tree.randomId(), Space.EMPTY, Markers.EMPTY,
                    Collections.emptyList(), "Implements", null, null),
                  JContainer.build(
                    Space.EMPTY,
                    Collections.singletonList(JRightPadded.build(
                      new J.Literal(Tree.randomId(), Space.EMPTY, Markers.EMPTY,
                        annotationValue, annotationValue, null,
                        JavaType.Primitive.String)
                    )),
                    Markers.EMPTY
                  )
                );

                List<J.Annotation> annotations = new ArrayList<>(classDecl.getLeadingAnnotations());
                annotations.add(implementsAnnotation);
                classDecl = classDecl.withLeadingAnnotations(annotations);
            }

            return classDecl;
        }

        private String getTypeName(TypeTree type) {
            if (type instanceof J.Identifier) {
                return ((J.Identifier)type).getSimpleName();
            }
            if (type instanceof J.FieldAccess) {
                return ((J.FieldAccess)type).getSimpleName();
            }
            if (type instanceof J.ParameterizedType) {
                NameTree clazz = ((J.ParameterizedType)type).getClazz();
                if (clazz instanceof TypeTree) {
                    return getTypeName((TypeTree)clazz);
                }
                return clazz.toString();
            }
            return type.toString();
        }

        @Override
        public  J.@Nullable VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {
            // Check if this field should be excluded
            if (shouldExcludeField(multiVariable)) {
                return null;
            }
            var annotations = multiVariable.getLeadingAnnotations();

            multiVariable = multiVariable.withLeadingAnnotations(annotations.stream().filter(x -> x.getSimpleName().contains("Nullable")).toList());
            // Remove all modifiers (private, final, etc.)
            return multiVariable.withModifiers(Collections.emptyList());
        }

        private boolean shouldExcludeField(J.VariableDeclarations field) {
            if (field.getTypeExpression() == null) {
                return false;
            }

            String typeStr = field.getTypeExpression().print();

            // Exclude SoftReference<TypesInUse> typesInUse
            if (typeStr.contains("SoftReference") && typeStr.contains("TypesInUse")) {
                return true;
            }

            // Exclude WeakReference<Padding> padding
            if (typeStr.contains("WeakReference") && typeStr.contains("Padding")) {
                return true;
            }

            return false;
        }

        @Override
        public  J.@Nullable MethodDeclaration visitMethodDeclaration(J.MethodDeclaration method, ExecutionContext ctx) {
            // Remove all methods
            return null;
        }
    }

    private static class JavaToCsharpTransformer extends JavaVisitor<ExecutionContext> {

        JavaParser parser = JavaParser.fromJavaVersion().build();
        @Override
        public J.VariableDeclarations visitVariableDeclarations(J.VariableDeclarations multiVariable, ExecutionContext ctx) {

            if(multiVariable.getVariables().getFirst().getSimpleName().equals("operatorKeyword")){
                System.out.println(multiVariable.getVariables().getFirst().getName());
            }

            var varName = multiVariable.getVariables().getFirst();
            varName = varName.withName(varName.getName().withSimpleName("_" + varName.getSimpleName()));
            multiVariable = multiVariable.withVariables(Collections.singletonList(varName));

            boolean isNullable = false;
            var type = multiVariable.getTypeExpression();
            if (type instanceof J.AnnotatedType) {
                type = ((J.AnnotatedType) type).getTypeExpression();
            }
            // Handle J.AnnotatedType to extract the innermost identifier



            var visitor = new JavaVisitor<>(){
                public boolean isNullable;

                @Override
                public @Nullable J visitAnnotation(J.Annotation annotation, Object o) {

                    var name = annotation.getSimpleName();
                    if(name.equals("Implements")){
                        return super.visitAnnotation(annotation, o);
                    }
                    if(name.equals("Nullable")){
                        isNullable = true;
                    }
                    return null;
                }
            };
            type = (TypeTree)visitor.visit(type, 0);
            isNullable = isNullable || visitor.isNullable;


            isNullable = isNullable || multiVariable
              .getLeadingAnnotations()
              .stream()
              .anyMatch(x -> x.getSimpleName().contains("Nullable"));

            type = remapType(type, "UUID", "Guid");
            type = remapType(type, "Path", "string");
            multiVariable = multiVariable.withTypeExpression(type);

            multiVariable = multiVariable.withLeadingAnnotations(new ArrayList<>());

            multiVariable = (J.VariableDeclarations)new NormalizeFormatVisitor<>().visitNonNull(multiVariable, ctx, new Cursor(null, multiVariable));
            multiVariable = (J.VariableDeclarations)new MinimumViableSpacingVisitor<>(null).visitNonNull(multiVariable, ctx, new Cursor(null, multiVariable));

            if(isNullable){

                multiVariable = multiVariable.withTypeExpression(new J.NullableType(
                  Tree.randomId(),
                  Space.EMPTY,
                  Markers.EMPTY,
                  new ArrayList<>(),
                  JRightPadded.build(multiVariable.getTypeExpression())));
            }

            if(varName.getSimpleName().equals("_interfaceSpecifier"))
            {
                System.out.println(varName.getSimpleName());
            }
//
//            multiVariable = multiVariable.withModifiers(Collections.singletonList(new J.Modifier(
//              Tree.randomId(),
//              Space.SINGLE_SPACE,
//              Markers.EMPTY,
//              "readonly",
//              J.Modifier.Type.LanguageExtension,
//              new ArrayList<>())
//            ));




            return multiVariable;
        }

        TypeTree remapType(TypeTree type, String fromType, String toType){
            if (type instanceof J.Identifier &&  ((J.Identifier)type).getSimpleName().equals(fromType)) {
                type = ((J.Identifier) type).withSimpleName(toType);
            }
            return type;
        }

        @Override
        public J visitIdentifier(J.Identifier ident, ExecutionContext executionContext) {
            if (ident.getSimpleName().equals("java.nio.file.Path")) {
                return new J.Identifier(Tree.randomId(),
                  Space.SINGLE_SPACE,
                  Markers.EMPTY,
                  Collections.emptyList(),
                  "string",
                  null,
                  null);
            }
            return super.visitIdentifier(ident, executionContext);
        }


        @Override
        public J visitClassDeclaration(J.ClassDeclaration classDecl, ExecutionContext executionContext) {
            var publicModifier = new J.Modifier(
              Tree.randomId(),
              Space.SINGLE_SPACE,
              Markers.EMPTY,
              null,
              J.Modifier.Type.Public,
              new ArrayList<>()
            );
            var modifiers = new ArrayList<J.Modifier>();
            modifiers.add(publicModifier);
            if(!classDecl.getKind().equals(J.ClassDeclaration.Kind.Type.Enum)) {
                modifiers.add(new J.Modifier(
                  Tree.randomId(),
                  Space.SINGLE_SPACE,
                  Markers.EMPTY,
                  "partial",
                  J.Modifier.Type.LanguageExtension,
                  new ArrayList<>()
                ));
            }

            classDecl = classDecl.withModifiers(modifiers);


            if(classDecl.getKind().equals(J.ClassDeclaration.Kind.Type.Class)) {
                J.Annotation allArgsAnnotation = new J.Annotation(
                  Tree.randomId(),
                  Space.format("\n    "),
                  Markers.EMPTY,
                  new J.Identifier(Tree.randomId(), Space.EMPTY, Markers.EMPTY,
                    Collections.emptyList(), "AllArgsConstructor", null, null),
                  null
                );
                classDecl = classDecl.withLeadingAnnotations(Collections.singletonList(allArgsAnnotation));
            }
            return super.visitClassDeclaration(classDecl, executionContext);
        }

        @Override
        public J visitEnumValueSet(J.EnumValueSet enums, ExecutionContext executionContext) {
            enums = enums.withTerminatedWithSemicolon(false);
            return super.visitEnumValueSet(enums, executionContext);
        }

        @Override
        public J visitPackage(J.Package pkg, ExecutionContext executionContext) {
            var newPackage = ((J.CompilationUnit)parser.parse("package Rewrite.RewriteCSharp;").findFirst().get()).getPackageDeclaration();
            return super.visitPackage(newPackage, executionContext);
        }

        @Override
        public J visitCompilationUnit(J.CompilationUnit cu, ExecutionContext executionContext) {
            var imports = """
              import System.Diagnostics;
              import System.Diagnostics.CodeAnalysis;
              import Rewrite.Core;
              import Rewrite.Core.Marker;
              import Rewrite.RewriteJava.Tree;
              import Rewrite.RewriteCSharp.Tree;
              import Rewrite.Analyzers;
              """;

            var parser = JavaParser.fromJavaVersion().build();
            var newImports = ((J.CompilationUnit)parser.parse(imports).findFirst().get()).getImports();

            cu = cu.withImports(newImports);
            return super.visitCompilationUnit(cu, executionContext);

        }


    }
}
