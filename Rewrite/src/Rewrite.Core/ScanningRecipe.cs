using System.Runtime.CompilerServices;

namespace Rewrite.Core;

    /// <summary>
    /// A recipe that may first scan a repository and study it in one pass over the
    /// repository's source files before, in another pass, it decides how to transform
    /// the code.
    /// <br/>
    /// New source file generation is part of this type as well, since in almost every case
    /// we check that a file doesn't yet exist (and perhaps other conditions) before deciding
    /// to generate a file.
    /// </summary>
    /// <typeparam name="TAccumulator">The type of the accumulator where scanning data is held until the transformation phase.</typeparam>
    public abstract class ScanningRecipe<TAccumulator> : Recipe where TAccumulator : class
    {
        private string? _recipeAccMessage;

        private string RecipeAccMessage => _recipeAccMessage ??= "org.openrewrite.recipe.acc." + Guid.NewGuid();

        /// <summary>
        /// </summary>
        /// <returns>The initial value of the accumulator before any source files have been iterated over.</returns>
        public abstract TAccumulator GetInitialValue(IExecutionContext ctx);

        /// <summary>
        /// A visitor that is called for each source file in the repository in an initial pass.
        /// Scanning data should be accumulated to <c>acc</c>. The first source file to visit
        /// will receive an <c>acc</c> value that is supplied by <see cref="GetInitialValue(ExecutionContext)"/>.
        /// <br/>
        /// Any changes that the scanning visitor makes to the source file will be discarded.
        /// </summary>
        /// <param name="acc">The accumulated scanning data.</param>
        /// <returns>A visitor that is called to collect scanning data on each source file.</returns>
        public abstract ITreeVisitor<Tree, IExecutionContext> GetScanner(TAccumulator acc);

        /// <summary>
        /// Generate new source files to add to the repository using information collected from scanning.
        /// </summary>
        /// <param name="acc">The accumulated scanning data.</param>
        /// <param name="generatedInThisCycle">Files generated by other recipes in this cycle.</param>
        /// <returns>A list of new source files.</returns>
        public virtual ICollection<SourceFile> Generate(TAccumulator acc, ICollection<SourceFile> generatedInThisCycle, IExecutionContext ctx)
        {
            return Generate(acc, ctx);
        }

        /// <summary>
        /// Generate new source files to add to the repository using information collected from scanning.
        /// </summary>
        /// <param name="acc">The accumulated scanning data.</param>
        /// <returns>A list of new source files.</returns>
        public virtual ICollection<SourceFile> Generate(TAccumulator acc, IExecutionContext ctx)
        {
            return new List<SourceFile>();
        }

        /// <summary>
        /// A visitor that is called in a second pass to perform transformation on each source file.
        /// To delete a source file, return <c>null</c> from the <see cref="TreeVisitor{T, P}.Visit(T, P)"/>
        /// method.
        /// </summary>
        /// <param name="acc">The accumulated scanning data.</param>
        /// <returns>A visitor that is called to perform transformation on each source file.</returns>
        public virtual ITreeVisitor<Tree, IExecutionContext> GetVisitor(TAccumulator acc)
        {
            return ITreeVisitor<Tree, IExecutionContext>.Noop();
        }

        public TAccumulator GetAccumulator(Cursor cursor, IExecutionContext ctx)
        {
            return cursor.GetRoot().ComputeMessageIfAbsent(RecipeAccMessage, m => GetInitialValue(ctx));
        }

        public override ITreeVisitor<Tree, IExecutionContext> GetVisitor()
        {
            return new ScanningRecipeVisitor(this);
        }

        private class ScanningRecipeVisitor : TreeVisitor<Tree, IExecutionContext>
        {
            private readonly ScanningRecipe<TAccumulator> _scanningRecipe;
            private ITreeVisitor<Tree, IExecutionContext>? _delegate;

            public ScanningRecipeVisitor(ScanningRecipe<TAccumulator> scanningRecipe)
            {
                this._scanningRecipe = scanningRecipe;
            }

            private ITreeVisitor<Tree, IExecutionContext> Delegate(IExecutionContext ctx)
            {
                if (_delegate == null)
                {
                    _delegate = _scanningRecipe.GetVisitor(_scanningRecipe.GetAccumulator(Cursor, ctx));
                }
                return _delegate;
            }

            public override bool IsAcceptable(SourceFile sourceFile, IExecutionContext ctx)
            {
                return Delegate(ctx).IsAcceptable(sourceFile, ctx);
            }

            public override Tree? Visit(Tree? tree, IExecutionContext ctx, Cursor parent)
            {
                return Delegate(ctx).Visit(tree, ctx, parent);
            }

            public override Tree? Visit(Tree? tree, IExecutionContext p, [CallerMemberName] string callingMethodName = "", [CallerArgumentExpression(nameof(tree))] string callingArgumentExpression = "")
            {
                return base.Visit(tree, p, callingMethodName, callingArgumentExpression);
            }
            
        }
    }