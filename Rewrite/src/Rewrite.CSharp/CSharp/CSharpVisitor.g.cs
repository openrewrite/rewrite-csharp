//------------------------------------------------------------------------------
// <auto-generated>
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0108 // 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable CS8767 // Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Rewrite.Core;
using Rewrite.RewriteCSharp.Tree;
using Rewrite.RewriteJava;
using Rewrite.RewriteJava.Tree;

namespace Rewrite.RewriteCSharp;

[SuppressMessage("ReSharper", "InconsistentNaming")]
[SuppressMessage("ReSharper", "ReturnTypeCanBeNotNullable")]
[SuppressMessage("ReSharper", "MergeCastWithTypeCheck")]
public class CSharpVisitor<P> : JavaVisitor<P>
{
    public override bool IsAcceptable(SourceFile sourceFile, P p)
    {
        return sourceFile is Cs;
    }

    public virtual J? VisitCompilationUnit(Cs.CompilationUnit node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.COMPILATION_UNIT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExterns(node.Padding.Externs.Map(el => VisitRightPadded(el, JRightPadded.Location.COMPILATION_UNIT_EXTERNS, p)));
        node = node.Padding.WithUsings(node.Padding.Usings.Map(el => VisitRightPadded(el, JRightPadded.Location.COMPILATION_UNIT_USINGS, p)));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.Padding.WithMembers(node.Padding.Members.Map(el => VisitRightPadded(el, JRightPadded.Location.COMPILATION_UNIT_MEMBERS, p)));
        node = node.WithEof(VisitSpace(node.Eof, Space.Location.COMPILATION_UNIT_EOF, p)!);
        return node;
    }

    public virtual J? VisitOperatorDeclaration(Cs.OperatorDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.OPERATOR_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.OperatorDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.OperatorDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithExplicitInterfaceSpecifier(node.Padding.ExplicitInterfaceSpecifier == null ? null : VisitRightPadded(node.Padding.ExplicitInterfaceSpecifier, JRightPadded.Location.OPERATOR_DECLARATION_EXPLICIT_INTERFACE_SPECIFIER, p));
        node = node.WithOperatorKeyword(VisitAndCast<Cs.Keyword>(node.OperatorKeyword, p)!);
        node = node.WithCheckedKeyword(VisitAndCast<Cs.Keyword>(node.CheckedKeyword, p));
        node = node.Padding.WithOperatorToken(VisitLeftPadded(node.Padding.OperatorToken, JLeftPadded.Location.OPERATOR_DECLARATION_OPERATOR_TOKEN, p)!);
        node = node.WithReturnType(VisitAndCast<TypeTree>(node.ReturnType, p)!);
        node = node.Padding.WithParameters(VisitContainer(node.Padding.Parameters, JContainer.Location.OPERATOR_DECLARATION_PARAMETERS, p)!);
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitRefExpression(Cs.RefExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.REF_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.RefExpression)
        {
            return tempExpression;
        }
        node = (Cs.RefExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitPointerType(Cs.PointerType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.POINTER_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.PointerType)
        {
            return tempExpression;
        }
        node = (Cs.PointerType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithElementType(VisitRightPadded(node.Padding.ElementType, JRightPadded.Location.POINTER_TYPE_ELEMENT_TYPE, p)!);
        return node;
    }

    public virtual J? VisitRefType(Cs.RefType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.REF_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.RefType)
        {
            return tempExpression;
        }
        node = (Cs.RefType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithReadonlyKeyword(VisitAndCast<J.Modifier>(node.ReadonlyKeyword, p));
        node = node.WithTypeIdentifier(VisitAndCast<TypeTree>(node.TypeIdentifier, p)!);
        return node;
    }

    public virtual J? VisitForEachVariableLoop(Cs.ForEachVariableLoop node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FOR_EACH_VARIABLE_LOOP_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.ForEachVariableLoop)
        {
            return tempStatement;
        }
        node = (Cs.ForEachVariableLoop) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithControlElement(VisitAndCast<Cs.ForEachVariableLoop.Control>(node.ControlElement, p)!);
        node = node.Padding.WithBody(VisitRightPadded(node.Padding.Body, JRightPadded.Location.FOR_EACH_VARIABLE_LOOP_BODY, p)!);
        return node;
    }

    public virtual J? VisitForEachVariableLoopControl(Cs.ForEachVariableLoop.Control node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FOR_EACH_VARIABLE_LOOP_CONTROL_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithVariable(VisitRightPadded(node.Padding.Variable, JRightPadded.Location.FOR_EACH_VARIABLE_LOOP_CONTROL_VARIABLE, p)!);
        node = node.Padding.WithIterable(VisitRightPadded(node.Padding.Iterable, JRightPadded.Location.FOR_EACH_VARIABLE_LOOP_CONTROL_ITERABLE, p)!);
        return node;
    }

    public virtual J? VisitNameColon(Cs.NameColon node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.NAME_COLON_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithName(VisitRightPadded(node.Padding.Name, JRightPadded.Location.NAME_COLON_NAME, p)!);
        return node;
    }

    public virtual J? VisitArgument(Cs.Argument node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ARGUMENT_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.Argument)
        {
            return tempExpression;
        }
        node = (Cs.Argument) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithNameColumn(node.Padding.NameColumn == null ? null : VisitRightPadded(node.Padding.NameColumn, JRightPadded.Location.ARGUMENT_NAME_COLUMN, p));
        node = node.WithRefKindKeyword(VisitAndCast<Cs.Keyword>(node.RefKindKeyword, p));
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitAnnotatedStatement(Cs.AnnotatedStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ANNOTATED_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.AnnotatedStatement)
        {
            return tempStatement;
        }
        node = (Cs.AnnotatedStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithStatement(VisitAndCast<Statement>(node.Statement, p)!);
        return node;
    }

    public virtual J? VisitArrayRankSpecifier(Cs.ArrayRankSpecifier node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ARRAY_RANK_SPECIFIER_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ArrayRankSpecifier)
        {
            return tempExpression;
        }
        node = (Cs.ArrayRankSpecifier) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithSizes(VisitContainer(node.Padding.Sizes, JContainer.Location.ARRAY_RANK_SPECIFIER_SIZES, p)!);
        return node;
    }

    public virtual J? VisitAssignmentOperation(Cs.AssignmentOperation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ASSIGNMENT_OPERATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.AssignmentOperation)
        {
            return tempStatement;
        }
        node = (Cs.AssignmentOperation) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.AssignmentOperation)
        {
            return tempExpression;
        }
        node = (Cs.AssignmentOperation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithVariable(VisitAndCast<Expression>(node.Variable, p)!);
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.ASSIGNMENT_OPERATION_OPERATOR, p)!);
        node = node.WithAssignment(VisitAndCast<Expression>(node.Assignment, p)!);
        return node;
    }

    public virtual J? VisitAttributeList(Cs.AttributeList node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ATTRIBUTE_LIST_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithTarget(node.Padding.Target == null ? null : VisitRightPadded(node.Padding.Target, JRightPadded.Location.ATTRIBUTE_LIST_TARGET, p));
        node = node.Padding.WithAttributes(node.Padding.Attributes.Map(el => VisitRightPadded(el, JRightPadded.Location.ATTRIBUTE_LIST_ATTRIBUTES, p)));
        return node;
    }

    public virtual J? VisitAwaitExpression(Cs.AwaitExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.AWAIT_EXPRESSION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.AwaitExpression)
        {
            return tempStatement;
        }
        node = (Cs.AwaitExpression) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.AwaitExpression)
        {
            return tempExpression;
        }
        node = (Cs.AwaitExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<J>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitStackAllocExpression(Cs.StackAllocExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.STACK_ALLOC_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.StackAllocExpression)
        {
            return tempExpression;
        }
        node = (Cs.StackAllocExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<J.NewArray>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitGotoStatement(Cs.GotoStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.GOTO_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.GotoStatement)
        {
            return tempStatement;
        }
        node = (Cs.GotoStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithCaseOrDefaultKeyword(VisitAndCast<Cs.Keyword>(node.CaseOrDefaultKeyword, p));
        node = node.WithTarget(VisitAndCast<Expression>(node.Target, p));
        return node;
    }

    public virtual J? VisitEventDeclaration(Cs.EventDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.EVENT_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.EventDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.EventDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithTypeExpression(VisitLeftPadded(node.Padding.TypeExpression, JLeftPadded.Location.EVENT_DECLARATION_TYPE_EXPRESSION, p)!);
        node = node.Padding.WithInterfaceSpecifier(node.Padding.InterfaceSpecifier == null ? null : VisitRightPadded(node.Padding.InterfaceSpecifier, JRightPadded.Location.EVENT_DECLARATION_INTERFACE_SPECIFIER, p));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.Padding.WithAccessors(node.Padding.Accessors == null ? null : VisitContainer(node.Padding.Accessors, JContainer.Location.EVENT_DECLARATION_ACCESSORS, p));
        return node;
    }

    public virtual J? VisitBinary(Cs.Binary node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.BINARY_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.Binary)
        {
            return tempExpression;
        }
        node = (Cs.Binary) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLeft(VisitAndCast<Expression>(node.Left, p)!);
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.BINARY_OPERATOR, p)!);
        node = node.WithRight(VisitAndCast<Expression>(node.Right, p)!);
        return node;
    }

    public virtual J? VisitBlockScopeNamespaceDeclaration(Cs.BlockScopeNamespaceDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.BlockScopeNamespaceDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.BlockScopeNamespaceDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithName(VisitRightPadded(node.Padding.Name, JRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_NAME, p)!);
        node = node.Padding.WithExterns(node.Padding.Externs.Map(el => VisitRightPadded(el, JRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_EXTERNS, p)));
        node = node.Padding.WithUsings(node.Padding.Usings.Map(el => VisitRightPadded(el, JRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_USINGS, p)));
        node = node.Padding.WithMembers(node.Padding.Members.Map(el => VisitRightPadded(el, JRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_MEMBERS, p)));
        node = node.WithEnd(VisitSpace(node.End, Space.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_END, p)!);
        return node;
    }

    public virtual J? VisitCollectionExpression(Cs.CollectionExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.COLLECTION_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.CollectionExpression)
        {
            return tempExpression;
        }
        node = (Cs.CollectionExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithElements(node.Padding.Elements.Map(el => VisitRightPadded(el, JRightPadded.Location.COLLECTION_EXPRESSION_ELEMENTS, p)));
        return node;
    }

    public virtual J? VisitExpressionStatement(Cs.ExpressionStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.EXPRESSION_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.ExpressionStatement)
        {
            return tempStatement;
        }
        node = (Cs.ExpressionStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.EXPRESSION_STATEMENT_EXPRESSION, p)!);
        return node;
    }

    public virtual J? VisitExternAlias(Cs.ExternAlias node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.EXTERN_ALIAS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.ExternAlias)
        {
            return tempStatement;
        }
        node = (Cs.ExternAlias) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithIdentifier(VisitLeftPadded(node.Padding.Identifier, JLeftPadded.Location.EXTERN_ALIAS_IDENTIFIER, p)!);
        return node;
    }

    public virtual J? VisitFileScopeNamespaceDeclaration(Cs.FileScopeNamespaceDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FILE_SCOPE_NAMESPACE_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.FileScopeNamespaceDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.FileScopeNamespaceDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithName(VisitRightPadded(node.Padding.Name, JRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_NAME, p)!);
        node = node.Padding.WithExterns(node.Padding.Externs.Map(el => VisitRightPadded(el, JRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_EXTERNS, p)));
        node = node.Padding.WithUsings(node.Padding.Usings.Map(el => VisitRightPadded(el, JRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_USINGS, p)));
        node = node.Padding.WithMembers(node.Padding.Members.Map(el => VisitRightPadded(el, JRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_MEMBERS, p)));
        return node;
    }

    public virtual J? VisitInterpolatedString(Cs.InterpolatedString node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.INTERPOLATED_STRING_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.InterpolatedString)
        {
            return tempExpression;
        }
        node = (Cs.InterpolatedString) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithParts(node.Padding.Parts.Map(el => VisitRightPadded(el, JRightPadded.Location.INTERPOLATED_STRING_PARTS, p)));
        return node;
    }

    public virtual J? VisitInterpolation(Cs.Interpolation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.INTERPOLATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.Interpolation)
        {
            return tempExpression;
        }
        node = (Cs.Interpolation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.INTERPOLATION_EXPRESSION, p)!);
        node = node.Padding.WithAlignment(node.Padding.Alignment == null ? null : VisitRightPadded(node.Padding.Alignment, JRightPadded.Location.INTERPOLATION_ALIGNMENT, p));
        node = node.Padding.WithFormat(node.Padding.Format == null ? null : VisitRightPadded(node.Padding.Format, JRightPadded.Location.INTERPOLATION_FORMAT, p));
        return node;
    }

    public virtual J? VisitNullSafeExpression(Cs.NullSafeExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.NULL_SAFE_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.NullSafeExpression)
        {
            return tempExpression;
        }
        node = (Cs.NullSafeExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.NULL_SAFE_EXPRESSION_EXPRESSION, p)!);
        return node;
    }

    public virtual J? VisitStatementExpression(Cs.StatementExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.STATEMENT_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.StatementExpression)
        {
            return tempExpression;
        }
        node = (Cs.StatementExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithStatement(VisitAndCast<Statement>(node.Statement, p)!);
        return node;
    }

    public virtual J? VisitUsingDirective(Cs.UsingDirective node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.USING_DIRECTIVE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.UsingDirective)
        {
            return tempStatement;
        }
        node = (Cs.UsingDirective) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithGlobal(VisitRightPadded(node.Padding.Global, JRightPadded.Location.USING_DIRECTIVE_GLOBAL, p)!);
        node = node.Padding.WithStatic(VisitLeftPadded(node.Padding.Static, JLeftPadded.Location.USING_DIRECTIVE_STATIC, p)!);
        node = node.Padding.WithUnsafe(VisitLeftPadded(node.Padding.Unsafe, JLeftPadded.Location.USING_DIRECTIVE_UNSAFE, p)!);
        node = node.Padding.WithAlias(node.Padding.Alias == null ? null : VisitRightPadded(node.Padding.Alias, JRightPadded.Location.USING_DIRECTIVE_ALIAS, p));
        node = node.WithNamespaceOrType(VisitAndCast<TypeTree>(node.NamespaceOrType, p)!);
        return node;
    }

    public virtual J? VisitPropertyDeclaration(Cs.PropertyDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PROPERTY_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.PropertyDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.PropertyDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p)!);
        node = node.Padding.WithInterfaceSpecifier(node.Padding.InterfaceSpecifier == null ? null : VisitRightPadded(node.Padding.InterfaceSpecifier, JRightPadded.Location.PROPERTY_DECLARATION_INTERFACE_SPECIFIER, p));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.WithAccessors(VisitAndCast<J.Block>(node.Accessors, p));
        node = node.WithExpressionBody(VisitAndCast<Cs.ArrowExpressionClause>(node.ExpressionBody, p));
        node = node.Padding.WithInitializer(node.Padding.Initializer == null ? null : VisitLeftPadded(node.Padding.Initializer, JLeftPadded.Location.PROPERTY_DECLARATION_INITIALIZER, p));
        return node;
    }

    public virtual J? VisitKeyword(Cs.Keyword node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.KEYWORD_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitLambda(Cs.Lambda node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LAMBDA_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.Lambda)
        {
            return tempStatement;
        }
        node = (Cs.Lambda) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.Lambda)
        {
            return tempExpression;
        }
        node = (Cs.Lambda) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLambdaExpression(VisitAndCast<J.Lambda>(node.LambdaExpression, p)!);
        node = node.WithReturnType(VisitAndCast<TypeTree>(node.ReturnType, p));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        return node;
    }

    public virtual J? VisitClassDeclaration(Cs.ClassDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CLASS_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.ClassDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.ClassDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeList(node.AttributeList.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithKind(VisitAndCast<J.ClassDeclaration.Kind>(node.Padding.Kind, p)!);
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.CLASS_DECLARATION_TYPE_PARAMETERS, p));
        node = node.Padding.WithPrimaryConstructor(node.Padding.PrimaryConstructor == null ? null : VisitContainer(node.Padding.PrimaryConstructor, JContainer.Location.CLASS_DECLARATION_PRIMARY_CONSTRUCTOR, p));
        node = node.Padding.WithExtendings(node.Padding.Extendings == null ? null : VisitLeftPadded(node.Padding.Extendings, JLeftPadded.Location.CLASS_DECLARATION_EXTENDINGS, p));
        node = node.Padding.WithImplementings(node.Padding.Implementings == null ? null : VisitContainer(node.Padding.Implementings, JContainer.Location.CLASS_DECLARATION_IMPLEMENTINGS, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p));
        node = node.Padding.WithTypeParameterConstraintClauses(node.Padding.TypeParameterConstraintClauses == null ? null : VisitContainer(node.Padding.TypeParameterConstraintClauses, JContainer.Location.CLASS_DECLARATION_TYPE_PARAMETER_CONSTRAINT_CLAUSES, p));
        return node;
    }

    public virtual J? VisitMethodDeclaration(Cs.MethodDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.METHOD_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.MethodDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.MethodDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributes(node.Attributes.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.METHOD_DECLARATION_TYPE_PARAMETERS, p));
        node = node.WithReturnTypeExpression(VisitAndCast<TypeTree>(node.ReturnTypeExpression, p)!);
        node = node.Padding.WithExplicitInterfaceSpecifier(node.Padding.ExplicitInterfaceSpecifier == null ? null : VisitRightPadded(node.Padding.ExplicitInterfaceSpecifier, JRightPadded.Location.METHOD_DECLARATION_EXPLICIT_INTERFACE_SPECIFIER, p));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.Padding.WithParameters(VisitContainer(node.Padding.Parameters, JContainer.Location.METHOD_DECLARATION_PARAMETERS, p)!);
        node = node.WithBody(VisitAndCast<Statement>(node.Body, p));
        node = node.Padding.WithTypeParameterConstraintClauses(VisitContainer(node.Padding.TypeParameterConstraintClauses, JContainer.Location.METHOD_DECLARATION_TYPE_PARAMETER_CONSTRAINT_CLAUSES, p)!);
        return node;
    }

    public virtual J? VisitUsingStatement(Cs.UsingStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.USING_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.UsingStatement)
        {
            return tempStatement;
        }
        node = (Cs.UsingStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAwaitKeyword(VisitAndCast<Cs.Keyword>(node.AwaitKeyword, p));
        node = node.Padding.WithExpression(VisitLeftPadded(node.Padding.Expression, JLeftPadded.Location.USING_STATEMENT_EXPRESSION, p)!);
        node = node.WithStatement(VisitAndCast<Statement>(node.Statement, p)!);
        return node;
    }

    public virtual J? VisitTypeParameterConstraintClause(Cs.TypeParameterConstraintClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_PARAMETER_CONSTRAINT_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithTypeParameter(VisitRightPadded(node.Padding.TypeParameter, JRightPadded.Location.TYPE_PARAMETER_CONSTRAINT_CLAUSE_TYPE_PARAMETER, p)!);
        node = node.Padding.WithTypeParameterConstraints(VisitContainer(node.Padding.TypeParameterConstraints, JContainer.Location.TYPE_PARAMETER_CONSTRAINT_CLAUSE_TYPE_PARAMETER_CONSTRAINTS, p)!);
        return node;
    }

    public virtual J? VisitTypeConstraint(Cs.TypeConstraint node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_CONSTRAINT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p)!);
        return node;
    }

    public virtual J? VisitAllowsConstraintClause(Cs.AllowsConstraintClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ALLOWS_CONSTRAINT_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpressions(VisitContainer(node.Padding.Expressions, JContainer.Location.ALLOWS_CONSTRAINT_CLAUSE_EXPRESSIONS, p)!);
        return node;
    }

    public virtual J? VisitRefStructConstraint(Cs.RefStructConstraint node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.REF_STRUCT_CONSTRAINT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitClassOrStructConstraint(Cs.ClassOrStructConstraint node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CLASS_OR_STRUCT_CONSTRAINT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitConstructorConstraint(Cs.ConstructorConstraint node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONSTRUCTOR_CONSTRAINT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitDefaultConstraint(Cs.DefaultConstraint node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DEFAULT_CONSTRAINT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitDeclarationExpression(Cs.DeclarationExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DECLARATION_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.DeclarationExpression)
        {
            return tempExpression;
        }
        node = (Cs.DeclarationExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p));
        node = node.WithVariables(VisitAndCast<Cs.VariableDesignation>(node.Variables, p)!);
        return node;
    }

    public virtual J? VisitSingleVariableDesignation(Cs.SingleVariableDesignation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SINGLE_VARIABLE_DESIGNATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.SingleVariableDesignation)
        {
            return tempExpression;
        }
        node = (Cs.SingleVariableDesignation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        return node;
    }

    public virtual J? VisitParenthesizedVariableDesignation(Cs.ParenthesizedVariableDesignation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PARENTHESIZED_VARIABLE_DESIGNATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ParenthesizedVariableDesignation)
        {
            return tempExpression;
        }
        node = (Cs.ParenthesizedVariableDesignation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithVariables(VisitContainer(node.Padding.Variables, JContainer.Location.PARENTHESIZED_VARIABLE_DESIGNATION_VARIABLES, p)!);
        return node;
    }

    public virtual J? VisitDiscardVariableDesignation(Cs.DiscardVariableDesignation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DISCARD_VARIABLE_DESIGNATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.DiscardVariableDesignation)
        {
            return tempExpression;
        }
        node = (Cs.DiscardVariableDesignation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithDiscard(VisitAndCast<J.Identifier>(node.Discard, p)!);
        return node;
    }

    public virtual J? VisitTupleExpression(Cs.TupleExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TUPLE_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.TupleExpression)
        {
            return tempExpression;
        }
        node = (Cs.TupleExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithArguments(VisitContainer(node.Padding.Arguments, JContainer.Location.TUPLE_EXPRESSION_ARGUMENTS, p)!);
        return node;
    }

    public virtual J? VisitConstructor(Cs.Constructor node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONSTRUCTOR_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.Constructor)
        {
            return tempStatement;
        }
        node = (Cs.Constructor) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithInitializer(VisitAndCast<Cs.ConstructorInitializer>(node.Initializer, p));
        node = node.WithConstructorCore(VisitAndCast<J.MethodDeclaration>(node.ConstructorCore, p)!);
        return node;
    }

    public virtual J? VisitDestructorDeclaration(Cs.DestructorDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DESTRUCTOR_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.DestructorDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.DestructorDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithMethodCore(VisitAndCast<J.MethodDeclaration>(node.MethodCore, p)!);
        return node;
    }

    public virtual J? VisitUnary(Cs.Unary node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.UNARY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.Unary)
        {
            return tempStatement;
        }
        node = (Cs.Unary) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.Unary)
        {
            return tempExpression;
        }
        node = (Cs.Unary) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.UNARY_OPERATOR, p)!);
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitConstructorInitializer(Cs.ConstructorInitializer node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONSTRUCTOR_INITIALIZER_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithKeyword(VisitAndCast<Cs.Keyword>(node.Keyword, p)!);
        node = node.Padding.WithArguments(VisitContainer(node.Padding.Arguments, JContainer.Location.CONSTRUCTOR_INITIALIZER_ARGUMENTS, p)!);
        return node;
    }

    public virtual J? VisitTupleType(Cs.TupleType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TUPLE_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.TupleType)
        {
            return tempExpression;
        }
        node = (Cs.TupleType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithElements(VisitContainer(node.Padding.Elements, JContainer.Location.TUPLE_TYPE_ELEMENTS, p)!);
        return node;
    }

    public virtual J? VisitTupleElement(Cs.TupleElement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TUPLE_ELEMENT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithType(VisitAndCast<TypeTree>(node.Type, p)!);
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p));
        return node;
    }

    public virtual J? VisitNewClass(Cs.NewClass node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.NEW_CLASS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.NewClass)
        {
            return tempStatement;
        }
        node = (Cs.NewClass) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.NewClass)
        {
            return tempExpression;
        }
        node = (Cs.NewClass) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithNewClassCore(VisitAndCast<J.NewClass>(node.NewClassCore, p)!);
        node = node.WithInitializer(VisitAndCast<Cs.InitializerExpression>(node.Initializer, p));
        return node;
    }

    public virtual J? VisitInitializerExpression(Cs.InitializerExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.INITIALIZER_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.InitializerExpression)
        {
            return tempExpression;
        }
        node = (Cs.InitializerExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpressions(VisitContainer(node.Padding.Expressions, JContainer.Location.INITIALIZER_EXPRESSION_EXPRESSIONS, p)!);
        return node;
    }

    public virtual J? VisitImplicitElementAccess(Cs.ImplicitElementAccess node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.IMPLICIT_ELEMENT_ACCESS_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ImplicitElementAccess)
        {
            return tempExpression;
        }
        node = (Cs.ImplicitElementAccess) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithArgumentList(VisitContainer(node.Padding.ArgumentList, JContainer.Location.IMPLICIT_ELEMENT_ACCESS_ARGUMENT_LIST, p)!);
        return node;
    }

    public virtual J? VisitYield(Cs.Yield node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.YIELD_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.Yield)
        {
            return tempStatement;
        }
        node = (Cs.Yield) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithReturnOrBreakKeyword(VisitAndCast<Cs.Keyword>(node.ReturnOrBreakKeyword, p)!);
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p));
        return node;
    }

    public virtual J? VisitDefaultExpression(Cs.DefaultExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DEFAULT_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.DefaultExpression)
        {
            return tempExpression;
        }
        node = (Cs.DefaultExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithTypeOperator(node.Padding.TypeOperator == null ? null : VisitContainer(node.Padding.TypeOperator, JContainer.Location.DEFAULT_EXPRESSION_TYPE_OPERATOR, p));
        return node;
    }

    public virtual J? VisitIsPattern(Cs.IsPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.IS_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.IsPattern)
        {
            return tempExpression;
        }
        node = (Cs.IsPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        node = node.Padding.WithPattern(VisitLeftPadded(node.Padding.Pattern, JLeftPadded.Location.IS_PATTERN_PATTERN, p)!);
        return node;
    }

    public virtual J? VisitUnaryPattern(Cs.UnaryPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.UNARY_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.UnaryPattern)
        {
            return tempExpression;
        }
        node = (Cs.UnaryPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithOperator(VisitAndCast<Cs.Keyword>(node.Operator, p)!);
        node = node.WithPattern(VisitAndCast<Cs.Pattern>(node.Pattern, p)!);
        return node;
    }

    public virtual J? VisitTypePattern(Cs.TypePattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.TypePattern)
        {
            return tempExpression;
        }
        node = (Cs.TypePattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeIdentifier(VisitAndCast<TypeTree>(node.TypeIdentifier, p)!);
        node = node.WithDesignation(VisitAndCast<Cs.VariableDesignation>(node.Designation, p));
        return node;
    }

    public virtual J? VisitBinaryPattern(Cs.BinaryPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.BINARY_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.BinaryPattern)
        {
            return tempExpression;
        }
        node = (Cs.BinaryPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLeft(VisitAndCast<Cs.Pattern>(node.Left, p)!);
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.BINARY_PATTERN_OPERATOR, p)!);
        node = node.WithRight(VisitAndCast<Cs.Pattern>(node.Right, p)!);
        return node;
    }

    public virtual J? VisitConstantPattern(Cs.ConstantPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONSTANT_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ConstantPattern)
        {
            return tempExpression;
        }
        node = (Cs.ConstantPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithValue(VisitAndCast<Expression>(node.Value, p)!);
        return node;
    }

    public virtual J? VisitDiscardPattern(Cs.DiscardPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DISCARD_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.DiscardPattern)
        {
            return tempExpression;
        }
        node = (Cs.DiscardPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitListPattern(Cs.ListPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LIST_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ListPattern)
        {
            return tempExpression;
        }
        node = (Cs.ListPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithPatterns(VisitContainer(node.Padding.Patterns, JContainer.Location.LIST_PATTERN_PATTERNS, p)!);
        node = node.WithDesignation(VisitAndCast<Cs.VariableDesignation>(node.Designation, p));
        return node;
    }

    public virtual J? VisitParenthesizedPattern(Cs.ParenthesizedPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PARENTHESIZED_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ParenthesizedPattern)
        {
            return tempExpression;
        }
        node = (Cs.ParenthesizedPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithPattern(VisitContainer(node.Padding.Pattern, JContainer.Location.PARENTHESIZED_PATTERN_PATTERN, p)!);
        return node;
    }

    public virtual J? VisitRecursivePattern(Cs.RecursivePattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.RECURSIVE_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.RecursivePattern)
        {
            return tempExpression;
        }
        node = (Cs.RecursivePattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeQualifier(VisitAndCast<TypeTree>(node.TypeQualifier, p));
        node = node.WithPositionalPattern(VisitAndCast<Cs.PositionalPatternClause>(node.PositionalPattern, p));
        node = node.WithPropertyPattern(VisitAndCast<Cs.PropertyPatternClause>(node.PropertyPattern, p));
        node = node.WithDesignation(VisitAndCast<Cs.VariableDesignation>(node.Designation, p));
        return node;
    }

    public virtual J? VisitVarPattern(Cs.VarPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.VAR_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.VarPattern)
        {
            return tempExpression;
        }
        node = (Cs.VarPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithDesignation(VisitAndCast<Cs.VariableDesignation>(node.Designation, p)!);
        return node;
    }

    public virtual J? VisitPositionalPatternClause(Cs.PositionalPatternClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.POSITIONAL_PATTERN_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithSubpatterns(VisitContainer(node.Padding.Subpatterns, JContainer.Location.POSITIONAL_PATTERN_CLAUSE_SUBPATTERNS, p)!);
        return node;
    }

    public virtual J? VisitRelationalPattern(Cs.RelationalPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.RELATIONAL_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.RelationalPattern)
        {
            return tempExpression;
        }
        node = (Cs.RelationalPattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.RELATIONAL_PATTERN_OPERATOR, p)!);
        node = node.WithValue(VisitAndCast<Expression>(node.Value, p)!);
        return node;
    }

    public virtual J? VisitSlicePattern(Cs.SlicePattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SLICE_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.SlicePattern)
        {
            return tempExpression;
        }
        node = (Cs.SlicePattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitPropertyPatternClause(Cs.PropertyPatternClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PROPERTY_PATTERN_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithSubpatterns(VisitContainer(node.Padding.Subpatterns, JContainer.Location.PROPERTY_PATTERN_CLAUSE_SUBPATTERNS, p)!);
        return node;
    }

    public virtual J? VisitSubpattern(Cs.Subpattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SUBPATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.Subpattern)
        {
            return tempExpression;
        }
        node = (Cs.Subpattern) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithName(VisitAndCast<Expression>(node.Name, p));
        node = node.Padding.WithPattern(VisitLeftPadded(node.Padding.Pattern, JLeftPadded.Location.SUBPATTERN_PATTERN, p)!);
        return node;
    }

    public virtual J? VisitSwitchExpression(Cs.SwitchExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SWITCH_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.SwitchExpression)
        {
            return tempExpression;
        }
        node = (Cs.SwitchExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.SWITCH_EXPRESSION_EXPRESSION, p)!);
        node = node.Padding.WithArms(VisitContainer(node.Padding.Arms, JContainer.Location.SWITCH_EXPRESSION_ARMS, p)!);
        return node;
    }

    public virtual J? VisitSwitchExpressionArm(Cs.SwitchExpressionArm node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SWITCH_EXPRESSION_ARM_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithPattern(VisitAndCast<Cs.Pattern>(node.Pattern, p)!);
        node = node.Padding.WithWhenExpression(node.Padding.WhenExpression == null ? null : VisitLeftPadded(node.Padding.WhenExpression, JLeftPadded.Location.SWITCH_EXPRESSION_ARM_WHEN_EXPRESSION, p));
        node = node.Padding.WithExpression(VisitLeftPadded(node.Padding.Expression, JLeftPadded.Location.SWITCH_EXPRESSION_ARM_EXPRESSION, p)!);
        return node;
    }

    public virtual J? VisitSwitchSection(Cs.SwitchSection node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SWITCH_SECTION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.SwitchSection)
        {
            return tempStatement;
        }
        node = (Cs.SwitchSection) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLabels(node.Labels.Map(el => (Cs.SwitchLabel?)Visit(el, p)));
        node = node.Padding.WithStatements(node.Padding.Statements.Map(el => VisitRightPadded(el, JRightPadded.Location.SWITCH_SECTION_STATEMENTS, p)));
        return node;
    }

    public virtual J? VisitDefaultSwitchLabel(Cs.DefaultSwitchLabel node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DEFAULT_SWITCH_LABEL_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.DefaultSwitchLabel)
        {
            return tempExpression;
        }
        node = (Cs.DefaultSwitchLabel) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithColonToken(VisitSpace(node.ColonToken, Space.Location.DEFAULT_SWITCH_LABEL_COLON_TOKEN, p)!);
        return node;
    }

    public virtual J? VisitCasePatternSwitchLabel(Cs.CasePatternSwitchLabel node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CASE_PATTERN_SWITCH_LABEL_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.CasePatternSwitchLabel)
        {
            return tempExpression;
        }
        node = (Cs.CasePatternSwitchLabel) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithPattern(VisitAndCast<Cs.Pattern>(node.Pattern, p)!);
        node = node.Padding.WithWhenClause(node.Padding.WhenClause == null ? null : VisitLeftPadded(node.Padding.WhenClause, JLeftPadded.Location.CASE_PATTERN_SWITCH_LABEL_WHEN_CLAUSE, p));
        node = node.WithColonToken(VisitSpace(node.ColonToken, Space.Location.CASE_PATTERN_SWITCH_LABEL_COLON_TOKEN, p)!);
        return node;
    }

    public virtual J? VisitSwitchStatement(Cs.SwitchStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SWITCH_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.SwitchStatement)
        {
            return tempStatement;
        }
        node = (Cs.SwitchStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitContainer(node.Padding.Expression, JContainer.Location.SWITCH_STATEMENT_EXPRESSION, p)!);
        node = node.Padding.WithSections(VisitContainer(node.Padding.Sections, JContainer.Location.SWITCH_STATEMENT_SECTIONS, p)!);
        return node;
    }

    public virtual J? VisitLockStatement(Cs.LockStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LOCK_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.LockStatement)
        {
            return tempStatement;
        }
        node = (Cs.LockStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<J.ControlParentheses<Expression>>(node.Expression, p)!);
        node = node.Padding.WithStatement(VisitRightPadded(node.Padding.Statement, JRightPadded.Location.LOCK_STATEMENT_STATEMENT, p)!);
        return node;
    }

    public virtual J? VisitFixedStatement(Cs.FixedStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FIXED_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.FixedStatement)
        {
            return tempStatement;
        }
        node = (Cs.FixedStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithDeclarations(VisitAndCast<J.ControlParentheses<J.VariableDeclarations>>(node.Declarations, p)!);
        node = node.WithBlock(VisitAndCast<J.Block>(node.Block, p)!);
        return node;
    }

    public virtual J? VisitCheckedExpression(Cs.CheckedExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CHECKED_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.CheckedExpression)
        {
            return tempExpression;
        }
        node = (Cs.CheckedExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithCheckedOrUncheckedKeyword(VisitAndCast<Cs.Keyword>(node.CheckedOrUncheckedKeyword, p)!);
        node = node.WithExpression(VisitAndCast<J.ControlParentheses<Expression>>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitCheckedStatement(Cs.CheckedStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CHECKED_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.CheckedStatement)
        {
            return tempStatement;
        }
        node = (Cs.CheckedStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithKeyword(VisitAndCast<Cs.Keyword>(node.Keyword, p)!);
        node = node.WithBlock(VisitAndCast<J.Block>(node.Block, p)!);
        return node;
    }

    public virtual J? VisitUnsafeStatement(Cs.UnsafeStatement node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.UNSAFE_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.UnsafeStatement)
        {
            return tempStatement;
        }
        node = (Cs.UnsafeStatement) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithBlock(VisitAndCast<J.Block>(node.Block, p)!);
        return node;
    }

    public virtual J? VisitRangeExpression(Cs.RangeExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.RANGE_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.RangeExpression)
        {
            return tempExpression;
        }
        node = (Cs.RangeExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithStart(node.Padding.Start == null ? null : VisitRightPadded(node.Padding.Start, JRightPadded.Location.RANGE_EXPRESSION_START, p));
        node = node.WithEnd(VisitAndCast<Expression>(node.End, p));
        return node;
    }

    public virtual J? VisitQueryExpression(Cs.QueryExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.QUERY_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.QueryExpression)
        {
            return tempExpression;
        }
        node = (Cs.QueryExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithFromClause(VisitAndCast<Cs.FromClause>(node.FromClause, p)!);
        node = node.WithBody(VisitAndCast<Cs.QueryBody>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitQueryBody(Cs.QueryBody node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.QUERY_BODY_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithClauses(node.Clauses.Map(el => (Cs.QueryClause?)Visit(el, p)));
        node = node.WithSelectOrGroup(VisitAndCast<Cs.SelectOrGroupClause>(node.SelectOrGroup, p));
        node = node.WithContinuation(VisitAndCast<Cs.QueryContinuation>(node.Continuation, p));
        return node;
    }

    public virtual J? VisitFromClause(Cs.FromClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FROM_CLAUSE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.FromClause)
        {
            return tempExpression;
        }
        node = (Cs.FromClause) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeIdentifier(VisitAndCast<TypeTree>(node.TypeIdentifier, p));
        node = node.Padding.WithIdentifier(VisitRightPadded(node.Padding.Identifier, JRightPadded.Location.FROM_CLAUSE_IDENTIFIER, p)!);
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitLetClause(Cs.LetClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LET_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithIdentifier(VisitRightPadded(node.Padding.Identifier, JRightPadded.Location.LET_CLAUSE_IDENTIFIER, p)!);
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitJoinClause(Cs.JoinClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.JOIN_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithIdentifier(VisitRightPadded(node.Padding.Identifier, JRightPadded.Location.JOIN_CLAUSE_IDENTIFIER, p)!);
        node = node.Padding.WithInExpression(VisitRightPadded(node.Padding.InExpression, JRightPadded.Location.JOIN_CLAUSE_IN_EXPRESSION, p)!);
        node = node.Padding.WithLeftExpression(VisitRightPadded(node.Padding.LeftExpression, JRightPadded.Location.JOIN_CLAUSE_LEFT_EXPRESSION, p)!);
        node = node.WithRightExpression(VisitAndCast<Expression>(node.RightExpression, p)!);
        node = node.Padding.WithInto(node.Padding.Into == null ? null : VisitLeftPadded(node.Padding.Into, JLeftPadded.Location.JOIN_CLAUSE_INTO, p));
        return node;
    }

    public virtual J? VisitJoinIntoClause(Cs.JoinIntoClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.JOIN_INTO_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithIdentifier(VisitAndCast<J.Identifier>(node.Identifier, p)!);
        return node;
    }

    public virtual J? VisitWhereClause(Cs.WhereClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.WHERE_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithCondition(VisitAndCast<Expression>(node.Condition, p)!);
        return node;
    }

    public virtual J? VisitOrderByClause(Cs.OrderByClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ORDER_BY_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithOrderings(node.Padding.Orderings.Map(el => VisitRightPadded(el, JRightPadded.Location.ORDER_BY_CLAUSE_ORDERINGS, p)));
        return node;
    }

    public virtual J? VisitQueryContinuation(Cs.QueryContinuation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.QUERY_CONTINUATION_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithIdentifier(VisitAndCast<J.Identifier>(node.Identifier, p)!);
        node = node.WithBody(VisitAndCast<Cs.QueryBody>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitOrdering(Cs.Ordering node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ORDERING_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.ORDERING_EXPRESSION, p)!);
        return node;
    }

    public virtual J? VisitSelectClause(Cs.SelectClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SELECT_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitGroupClause(Cs.GroupClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.GROUP_CLAUSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithGroupExpression(VisitRightPadded(node.Padding.GroupExpression, JRightPadded.Location.GROUP_CLAUSE_GROUP_EXPRESSION, p)!);
        node = node.WithKey(VisitAndCast<Expression>(node.Key, p)!);
        return node;
    }

    public virtual J? VisitIndexerDeclaration(Cs.IndexerDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.INDEXER_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.IndexerDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.IndexerDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p)!);
        node = node.Padding.WithExplicitInterfaceSpecifier(node.Padding.ExplicitInterfaceSpecifier == null ? null : VisitRightPadded(node.Padding.ExplicitInterfaceSpecifier, JRightPadded.Location.INDEXER_DECLARATION_EXPLICIT_INTERFACE_SPECIFIER, p));
        node = node.WithIndexer(VisitAndCast<Expression>(node.Indexer, p)!);
        node = node.Padding.WithParameters(VisitContainer(node.Padding.Parameters, JContainer.Location.INDEXER_DECLARATION_PARAMETERS, p)!);
        node = node.Padding.WithExpressionBody(node.Padding.ExpressionBody == null ? null : VisitLeftPadded(node.Padding.ExpressionBody, JLeftPadded.Location.INDEXER_DECLARATION_EXPRESSION_BODY, p));
        node = node.WithAccessors(VisitAndCast<J.Block>(node.Accessors, p));
        return node;
    }

    public virtual J? VisitDelegateDeclaration(Cs.DelegateDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DELEGATE_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.DelegateDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.DelegateDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributes(node.Attributes.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithReturnType(VisitLeftPadded(node.Padding.ReturnType, JLeftPadded.Location.DELEGATE_DECLARATION_RETURN_TYPE, p)!);
        node = node.WithIdentifier(VisitAndCast<J.Identifier>(node.Identifier, p)!);
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.DELEGATE_DECLARATION_TYPE_PARAMETERS, p));
        node = node.Padding.WithParameters(VisitContainer(node.Padding.Parameters, JContainer.Location.DELEGATE_DECLARATION_PARAMETERS, p)!);
        node = node.Padding.WithTypeParameterConstraintClauses(node.Padding.TypeParameterConstraintClauses == null ? null : VisitContainer(node.Padding.TypeParameterConstraintClauses, JContainer.Location.DELEGATE_DECLARATION_TYPE_PARAMETER_CONSTRAINT_CLAUSES, p));
        return node;
    }

    public virtual J? VisitConversionOperatorDeclaration(Cs.ConversionOperatorDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONVERSION_OPERATOR_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.ConversionOperatorDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.ConversionOperatorDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithKind(VisitLeftPadded(node.Padding.Kind, JLeftPadded.Location.CONVERSION_OPERATOR_DECLARATION_KIND, p)!);
        node = node.Padding.WithReturnType(VisitLeftPadded(node.Padding.ReturnType, JLeftPadded.Location.CONVERSION_OPERATOR_DECLARATION_RETURN_TYPE, p)!);
        node = node.Padding.WithParameters(VisitContainer(node.Padding.Parameters, JContainer.Location.CONVERSION_OPERATOR_DECLARATION_PARAMETERS, p)!);
        node = node.Padding.WithExpressionBody(node.Padding.ExpressionBody == null ? null : VisitLeftPadded(node.Padding.ExpressionBody, JLeftPadded.Location.CONVERSION_OPERATOR_DECLARATION_EXPRESSION_BODY, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p));
        return node;
    }

    public virtual J? VisitTypeParameter(Cs.TypeParameter node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_PARAMETER_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.Padding.WithVariance(node.Padding.Variance == null ? null : VisitLeftPadded(node.Padding.Variance, JLeftPadded.Location.TYPE_PARAMETER_VARIANCE, p));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        return node;
    }

    public virtual J? VisitEnumDeclaration(Cs.EnumDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ENUM_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.EnumDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.EnumDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists?.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithName(VisitLeftPadded(node.Padding.Name, JLeftPadded.Location.ENUM_DECLARATION_NAME, p)!);
        node = node.Padding.WithBaseType(node.Padding.BaseType == null ? null : VisitLeftPadded(node.Padding.BaseType, JLeftPadded.Location.ENUM_DECLARATION_BASE_TYPE, p));
        node = node.Padding.WithMembers(node.Padding.Members == null ? null : VisitContainer(node.Padding.Members, JContainer.Location.ENUM_DECLARATION_MEMBERS, p));
        return node;
    }

    public virtual J? VisitEnumMemberDeclaration(Cs.EnumMemberDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ENUM_MEMBER_DECLARATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.EnumMemberDeclaration)
        {
            return tempExpression;
        }
        node = (Cs.EnumMemberDeclaration) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributeLists(node.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.Padding.WithInitializer(node.Padding.Initializer == null ? null : VisitLeftPadded(node.Padding.Initializer, JLeftPadded.Location.ENUM_MEMBER_DECLARATION_INITIALIZER, p));
        return node;
    }

    public virtual J? VisitAliasQualifiedName(Cs.AliasQualifiedName node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ALIAS_QUALIFIED_NAME_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.AliasQualifiedName)
        {
            return tempExpression;
        }
        node = (Cs.AliasQualifiedName) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithAlias(VisitRightPadded(node.Padding.Alias, JRightPadded.Location.ALIAS_QUALIFIED_NAME_ALIAS, p)!);
        node = node.WithName(VisitAndCast<Expression>(node.Name, p)!);
        return node;
    }

    public virtual J? VisitArrayType(Cs.ArrayType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ARRAY_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.ArrayType)
        {
            return tempExpression;
        }
        node = (Cs.ArrayType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p));
        node = node.WithDimensions(node.Dimensions.Map(el => (J.ArrayDimension?)Visit(el, p)));
        return node;
    }

    public virtual J? VisitTry(Cs.Try node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TRY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.Try)
        {
            return tempStatement;
        }
        node = (Cs.Try) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        node = node.WithCatches(node.Catches.Map(el => (Cs.Try.Catch?)Visit(el, p)));
        node = node.Padding.WithFinally(node.Padding.Finally == null ? null : VisitLeftPadded(node.Padding.Finally, JLeftPadded.Location.TRY_FINALLIE, p));
        return node;
    }

    public virtual J? VisitTryCatch(Cs.Try.Catch node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TRY_CATCH_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithParameter(VisitAndCast<J.ControlParentheses<J.VariableDeclarations>>(node.Parameter, p)!);
        node = node.Padding.WithFilterExpression(node.Padding.FilterExpression == null ? null : VisitLeftPadded(node.Padding.FilterExpression, JLeftPadded.Location.TRY_CATCH_FILTER_EXPRESSION, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitArrowExpressionClause(Cs.ArrowExpressionClause node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ARROW_EXPRESSION_CLAUSE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.ArrowExpressionClause)
        {
            return tempStatement;
        }
        node = (Cs.ArrowExpressionClause) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.ARROW_EXPRESSION_CLAUSE_EXPRESSION, p)!);
        return node;
    }

    public virtual J? VisitAccessorDeclaration(Cs.AccessorDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ACCESSOR_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.AccessorDeclaration)
        {
            return tempStatement;
        }
        node = (Cs.AccessorDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAttributes(node.Attributes.Map(el => (Cs.AttributeList?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithKind(VisitLeftPadded(node.Padding.Kind, JLeftPadded.Location.ACCESSOR_DECLARATION_KIND, p)!);
        node = node.WithExpressionBody(VisitAndCast<Cs.ArrowExpressionClause>(node.ExpressionBody, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p));
        return node;
    }

    public virtual J? VisitPointerFieldAccess(Cs.PointerFieldAccess node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.POINTER_FIELD_ACCESS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not Cs.PointerFieldAccess)
        {
            return tempStatement;
        }
        node = (Cs.PointerFieldAccess) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not Cs.PointerFieldAccess)
        {
            return tempExpression;
        }
        node = (Cs.PointerFieldAccess) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTarget(VisitAndCast<Expression>(node.Target, p)!);
        node = node.Padding.WithName(VisitLeftPadded(node.Padding.Name, JLeftPadded.Location.POINTER_FIELD_ACCESS_NAME, p)!);
        return node;
    }

}
