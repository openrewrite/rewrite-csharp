using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Formatting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;
using Microsoft.CodeAnalysis.Text;
using Rewrite.RewriteCSharp.Tree;
using Rewrite.RewriteJava.Tree;

namespace Rewrite.RewriteCSharp.Format;


public class AutoFormatVisitor<TState> : CSharpVisitor<TState>
{
    private readonly Core.Tree? _stopAfter;

    public AutoFormatVisitor() : this(null)
    {
    }

    public AutoFormatVisitor(Core.Tree? stopAfter)
    {
        _stopAfter = stopAfter;
    }

    public override J? Visit(Core.Tree? tree, TState p, [CallerMemberName] string callingMethodName = "", [CallerArgumentExpression(nameof(tree))] string callingArgumentExpression = "")
    {
        return Visit(tree, p, new Cursor());
    }

    public override J? Visit(Core.Tree? tree, TState p, Cursor cursor)
    {
        // we only wanna act on the root
        var cu = tree as Cs.CompilationUnit ?? cursor.FirstEnclosingOrThrow<Cs.CompilationUnit>();
        var originalCode = cu.ToString()!;

        var roslynCu = SyntaxFactory.ParseCompilationUnit(originalCode);

        SyntaxNode roslynNodeToFormat = roslynCu;
        var style = FormatStyle.DetectStyle(originalCode);
        var workspace = new AdhocWorkspace();
        var options = workspace.Options
            .WithChangedOption(FormattingOptions.UseTabs, LanguageNames.CSharp, style.UseTabs)
            .WithChangedOption(FormattingOptions.IndentationSize, LanguageNames.CSharp, style.IdentationSize)
            .WithChangedOption(FormattingOptions.NewLine, LanguageNames.CSharp, style.NewLine)
            ;
        roslynCu = AnnotateAllTriviasWithElastic(roslynCu, roslynNodeToFormat);
        if (_stopAfter != null)
        {
            var nodeSpanMapper = new TreeMapVisitor();
            nodeSpanMapper.Visit(cu, new PrintOutputCapture<int>(0));
            var lstSpanForTargetNode = nodeSpanMapper.SpanMap[_stopAfter];
            roslynNodeToFormat = roslynCu.FindNode(lstSpanForTargetNode);

            options = options.WithChangedOption(CSharpFormattingOptions.WrappingPreserveSingleLine, true);
        }



        // apply formatting to roslyn node and merge it back into compilation unit
        var spanToFormat = GetOuterTokensSpan(roslynNodeToFormat);
        var formattedRoslynCu = Formatter.Format(roslynCu, spanToFormat, workspace, options);


        // ensure all whitespace is unique reference objects as that's how we're going to be targeting them since they don't have ID
        var uniqueSpaceVisitor = new UniqueSpaceVisitor();
        tree = uniqueSpaceVisitor.Visit(tree, 0);

        var changes = GetWhitespaceChanges(roslynCu.ToFullString(), formattedRoslynCu.ToFullString());
        // compose list of whitespace changes that need to be made
        var spaceChangeScanner = new SpaceChangeScannerVisitor(changes);
        spaceChangeScanner.Visit(tree, new PrintOutputCapture<int>(0));
        // apply whitespace changes and generate new tree
        var applier = new SpaceChangeApplierVisitor();
        tree = applier.Visit(tree, spaceChangeScanner.PendingSpaceChanges);

        return (J?)tree;
    }

    /// <summary>Gets span between node's previous token and node's next token</summary>
    private TextSpan GetOuterTokensSpan(SyntaxNode node)
    {
        var start = node.GetFirstToken().GetPreviousToken().Span.Start;
        var nextToken = node.GetLastToken().GetNextToken();
        var end = nextToken.IsPresent() ? nextToken.SpanStart : node.Span.End;
        var span = new TextSpan(start, end-start);
        return span;
    }

    /// <summary>
    /// Within a given compilation unit, marks all trivia belonging to subnode as Elastic. This ensures that formatter will not try to preserve
    /// any formatting for it as it's considered "autogenerated".
    /// </summary>
    /// <param name="compilationUnit"><see cref="CompilationUnitSyntax"/> containing <paramref name="node"/></param>
    /// <param name="node">Node to mark as elastic</param>
    /// <returns></returns>
    private CompilationUnitSyntax AnnotateAllTriviasWithElastic(CompilationUnitSyntax compilationUnit, SyntaxNode node)
    {
        var allTrivias = node.DescendantTrivia();
        var modifiedNode = node.ReplaceTrivia(allTrivias, (original, _) => original.WithAdditionalAnnotations(SyntaxAnnotation.ElasticAnnotation));

        return compilationUnit.ReplaceNode(node, modifiedNode);
    }

    /// <summary>
    /// Compares two C# code strings and returns a list of text changes representing the whitespace differences between them.
    /// Will only work correctly with valid C# syntax.
    /// </summary>
    /// <param name="before">The original C# code string.</param>
    /// <param name="after">The modified C# code string.</param>
    /// <returns>A list of TextChange objects representing whitespace differences.</returns>
    /// <exception cref="InvalidOperationException">Thrown when the chunker produces different number of elements for before and after strings.</exception>
    public static List<TextChange> GetWhitespaceChanges(string before, string after)
    {
        var chunker = new TriviaChunker();
        var beforeChunks = chunker.Chunk(before);
        var afterChunks = chunker.Chunk(after);

        if (beforeChunks.Length != afterChunks.Length)
        {
            throw new InvalidOperationException("Chunker should produce the same number of elements for before and after.");
        }

        var changes = new List<TextChange>();
        int position = 0;

        // Compare chunks and track position to create TextChange objects for differences
        for (int i = 0; i < beforeChunks.Length; i++)
        {
            var beforeChunk = beforeChunks[i];
            var afterChunk = afterChunks[i];

            if (beforeChunk != afterChunk)
            {
                changes.Add(new TextChange(new TextSpan(position, beforeChunk.Length), beforeChunk, afterChunk));
            }

            position += beforeChunk.Length;
        }

        return changes;
    }

    /// <summary>
    /// Maps all LST nodes to <see cref="TextSpan"/> they occupy when printed out
    /// </summary>
    private class TreeMapVisitor : CSharpPrinter<int>
    {
        public Dictionary<Rewrite.Core.Tree, TextSpan> SpanMap { get; } = new();

        public override J? PreVisit(Rewrite.Core.Tree? tree, PrintOutputCapture<int> p)
        {
            if (tree != null)
            {
                var j = (J)tree;
                SpanMap.Add(tree, new TextSpan(p.Out.Length + j.Prefix.ToString().Length, 0));
            }
            return tree as J;
        }

        public override J? PostVisit(Rewrite.Core.Tree tree, PrintOutputCapture<int> p)
        {
            if (SpanMap.TryGetValue(tree, out TextSpan span))
            {
                SpanMap[tree] = new TextSpan(span.Start, p.Out.Length - span.Start);
            }
            return tree as J;
        }
    }

    /// <summary>
    /// Converts list of whitespace changes to list of transform targeting specific space elements (PendingSpaceChanges)
    /// This is a two stage process as we we're relying to Printer to map which Space objects in LST correspond to textspans from <param name="changes"/>
    /// and schedule modification operation.
    /// </summary>
    /// <param name="changes"></param>
    private class SpaceChangeScannerVisitor(IList<TextChange> changes) : CSharpPrinter<int>
    {
        private readonly HashSet<TextChange> _changes = new(changes);
        public Dictionary<Space, List<Func<Space, Space>>> PendingSpaceChanges { get; } = new();

        public override Space VisitSpace(Space space, Space.Location? loc, PrintOutputCapture<int> p)
        {
            return VisitSpace(space, () => base.VisitSpace(space, loc, p), p);
        }

        public Space VisitSpace(Space space, Action visitBase, PrintOutputCapture<int> p)
        {
            if (space == Space.EMPTY)
                return space; // special case cuz markers are hardcoded with Space.Empty
            var start = p.Out.Length;
            visitBase();
            var end = p.Out.Length;
            var span = new TextSpan(start, end - start);

            var overlappingChanges = _changes.Where(change => span.IntersectsWith(change.Span)).ToList();

            if (overlappingChanges.Count > 1)
            {
                throw new Exception("Found multiple changes affecting same textspan area");
            }

            if (overlappingChanges.Count > 0)
            {
                var change = overlappingChanges.FirstOrDefault();
                var changeTargetString = change.OldText;
                var currentSpaceString = space.ToString();
                // make sure the change is actually being applied to correct space it was originally computed from,
                // since it's possible we had an empty Space occupying same region in original (overlap conflict)
                if (currentSpaceString != changeTargetString)
                {
                    return space;
                }

                var newWhitespace = ApplyChanges(span, space.Whitespace, overlappingChanges);
                var newSpace = Space.Format(newWhitespace);
                PendingSpaceChanges.Upsert(space, x => x.WithWhitespace(newSpace.Whitespace));
            }

            return space;
        }

        string ApplyChanges(TextSpan beforeSpan, string beforeWhitespace, List<TextChange> changes)
        {
            var sb = new StringBuilder();
            using var currentChangeEnumerator = changes.GetEnumerator();
            var hasChange = currentChangeEnumerator.MoveNext();
            for (int i = beforeSpan.Start; i <= beforeSpan.End; i++)
            {
                var currentPositionInBefore = i - beforeSpan.Start;
                if (hasChange && i >= currentChangeEnumerator.Current.Span.Start)
                {
                    sb.Append(currentChangeEnumerator.Current.NewText);
                    i = currentChangeEnumerator.Current.Span.End - 1;
                    // remove it so we don't apply it twice in case multiple Space objects overlaps same region
                    _changes.Remove(currentChangeEnumerator.Current);
                    hasChange = currentChangeEnumerator.MoveNext();
                }
                else if (currentPositionInBefore < beforeWhitespace.Length)
                {
                    sb.Append(beforeWhitespace[currentPositionInBefore]);
                }
            }

            return sb.ToString();
        }
    }

    /// <summary>
    /// Walks the tree and for each Space object performs scheduled transformations produced by <see cref="SpaceChangeScannerVisitor"/>
    /// </summary>
    private class SpaceChangeApplierVisitor : CSharpIsoVisitor<Dictionary<Space, List<Func<Space, Space>>>>
    {

        public override Space VisitSpace(Space space, Space.Location? loc, Dictionary<Space, List<Func<Space, Space>>> p)
        {
            var newSpace = ApplyChange(space, p);
            return newSpace;
        }

        private Space ApplyChange(Space space, Dictionary<Space, List<Func<Space, Space>>> p)
        {
            if (p.TryGetValue(space, out var spaceApplier))
            {
                foreach (var applySpace in spaceApplier)
                {
                    space = applySpace(space);
                }
            }

            return space;
        }
    }


}
