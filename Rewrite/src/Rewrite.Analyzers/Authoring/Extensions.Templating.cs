using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Rewrite.Analyzers.Authoring;

[PublicAPI]
public static partial class Extensions
{
    public const string AutoGeneratedHeader =
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     Changes to this file may cause incorrect behavior and will be lost if
        //     the code is regenerated.
        // </auto-generated>
        //------------------------------------------------------------------------------
        """;
    
    

    private static HashSet<string> _reservedWords =
    [
        "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern",
        "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override",
        "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint",
        "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while"
    ];

    public static string EnsureSafeIdentifier(this string s) => $"{s[0].ToString().ToLower()}{s.Remove(0, 1)}";
    public static string ToCamelCase(this string s) => $"{s[0].ToString().ToLower()}{s.Remove(0, 1)}";


    public static string Ident(this object source, int identLevels)
    {
        var lines = source.ToString()?.TrimStart(' ').Split('\n') ?? [];
        var ident = new string(' ', identLevels * 4);
        return string.Join("\n", lines.Select((x, i) => $"""{ (i > 0 ? ident : "") }{x}"""));
    }

    public static string RenderParameters(
        this IEnumerable<string> source)
    {
        return Render(source, x => x, separator: "\", \"", "(\"", "\")");
    }
    
    public static string RenderParameters<T>(
        this IEnumerable<T> source,
        Func<T, string> template)
    {
        return Render(source, template, separator: ", ", "(", ")");
    }
    public static string RenderStatements<T>(
        this IEnumerable<T> source,
        Func<T, string> template)
    {
        return Render(source, template, separator: "\n");
    }
    public static string RenderBlock<T>(
        this IEnumerable<T> source,
        Func<T, string> template)
    {
        return Render(source, template, separator: "\n", "{", "}");
    }
    public static string Render<T>(
        this IEnumerable<T> source,
        Func<T, string> template,
        string separator = "",
        string openToken = "",
        string closeToken = "",
        bool renderEmpty = true)
    {

        var renderedItems = source.Select(template).ToArray();
        
        if (!renderEmpty && renderedItems.Length == 0)
            return "";
        
        bool multiline = renderedItems.Any(r => r.Contains('\n'));

        if (multiline)
        {
            var outerIndent = IndentationContext.CurrentIndent;

            using (IndentationContext.Increase())
            {
                var innerRender = IndentationContext.RenderIndented(renderedItems);

                return $"{outerIndent}{openToken}\n{innerRender}\n{outerIndent}{closeToken}";
            }
        }
        else
        {
            return $"{IndentationContext.CurrentIndent}{openToken}{string.Join(separator, renderedItems)}{closeToken}";
        }
    }


    public static string Render<T>(this IEnumerable<T> source, Func<T, int, string> template, string separator = "")
    {
        return string.Join(separator, source.Select(template));
    }

    public static void RenderSourceFile<T>(this T partialTemplateModel, Func<T, string> renderBody, SourceProductionContext context, bool renderEmpty = false) where T : PartialTypeModel
    {
        var body = renderBody(partialTemplateModel);
        if(!renderEmpty && string.IsNullOrWhiteSpace(body))
            return;
        var sourceCode = partialTemplateModel.RenderPartial(_ => body);
        
        context.AddSource(partialTemplateModel.FileName, SourceText.From(sourceCode, Encoding.UTF8));
    }
    public static string RenderPartial<T>(this T partialTemplateModel, Func<T, string> renderBody) where T : PartialTypeModel
    {
        var body = renderBody(partialTemplateModel);
        IndentationContext.CurrentLevel = partialTemplateModel.IdentLevel;
        var indentedBody = IndentationContext.RenderIndented(body);
        var result = partialTemplateModel.PartialDeclarationTemplate.Replace(PartialTypeModel.ReplaceToken, indentedBody);
        return result;
    }

    
    
    public static string GetGeneratorQualifiedSourceFileName(this TypeDeclarationSyntax partialType, IIncrementalGenerator generator) =>
        $"{Regex.Replace(generator.GetType().Name, "(Source)?(Generator)?$","")}{partialType.GetInferredFilename()}.g.cs";

}
