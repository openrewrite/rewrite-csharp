//------------------------------------------------------------------------------
// <auto-generated>
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0108 // 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable CS8767 // Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).
using System.Diagnostics.CodeAnalysis;
using Rewrite.Core;
using Rewrite.RewriteCSharp.Tree;
using Rewrite.RewriteJava;
using Rewrite.RewriteJava.Tree;

namespace Rewrite.RewriteCSharp;

[SuppressMessage("ReSharper", "InconsistentNaming")]
[SuppressMessage("ReSharper", "ReturnTypeCanBeNotNullable")]
[SuppressMessage("ReSharper", "MergeCastWithTypeCheck")]
public class CSharpVisitor<P> : JavaVisitor<P>
{
    public override bool IsAcceptable(SourceFile sourceFile, P p)
    {
        return sourceFile is Cs;
    }

    public virtual J? VisitCompilationUnit(Cs.CompilationUnit compilationUnit, P p)
    {
        compilationUnit = compilationUnit.WithPrefix(VisitSpace(compilationUnit.Prefix, Space.Location.COMPILATION_UNIT_PREFIX, p)!);
        compilationUnit = compilationUnit.WithMarkers(VisitMarkers(compilationUnit.Markers, p));
        compilationUnit = compilationUnit.Padding.WithExterns(compilationUnit.Padding.Externs.Map(el => VisitRightPadded(el, CsRightPadded.Location.COMPILATION_UNIT_EXTERNS, p)));
        compilationUnit = compilationUnit.Padding.WithUsings(compilationUnit.Padding.Usings.Map(el => VisitRightPadded(el, CsRightPadded.Location.COMPILATION_UNIT_USINGS, p)));
        compilationUnit = compilationUnit.WithAttributeLists(compilationUnit.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        compilationUnit = compilationUnit.Padding.WithMembers(compilationUnit.Padding.Members.Map(el => VisitRightPadded(el, CsRightPadded.Location.COMPILATION_UNIT_MEMBERS, p)));
        compilationUnit = compilationUnit.WithEof(VisitSpace(compilationUnit.Eof, Space.Location.COMPILATION_UNIT_EOF, p)!);
        return compilationUnit;
    }

    public virtual J? VisitForEachVariableLoop(Cs.ForEachVariableLoop forEachVariableLoop, P p)
    {
        forEachVariableLoop = forEachVariableLoop.WithPrefix(VisitSpace(forEachVariableLoop.Prefix, CsSpace.Location.FOR_EACH_VARIABLE_LOOP_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(forEachVariableLoop, p);
        if (tempStatement is not Cs.ForEachVariableLoop)
        {
            return tempStatement;
        }
        forEachVariableLoop = (Cs.ForEachVariableLoop) tempStatement;
        forEachVariableLoop = forEachVariableLoop.WithMarkers(VisitMarkers(forEachVariableLoop.Markers, p));
        forEachVariableLoop = forEachVariableLoop.WithControlElement(VisitAndCast<Cs.ForEachVariableLoop.Control>(forEachVariableLoop.ControlElement, p)!);
        forEachVariableLoop = forEachVariableLoop.Padding.WithBody(VisitRightPadded(forEachVariableLoop.Padding.Body, CsRightPadded.Location.FOR_EACH_VARIABLE_LOOP_BODY, p)!);
        return forEachVariableLoop;
    }

    public virtual J? VisitForEachVariableLoopControl(Cs.ForEachVariableLoop.Control control, P p)
    {
        control = control.WithPrefix(VisitSpace(control.Prefix, CsSpace.Location.FOR_EACH_VARIABLE_LOOP_CONTROL_PREFIX, p)!);
        control = control.WithMarkers(VisitMarkers(control.Markers, p));
        control = control.Padding.WithVariable(VisitRightPadded(control.Padding.Variable, CsRightPadded.Location.FOR_EACH_VARIABLE_LOOP_CONTROL_VARIABLE, p)!);
        control = control.Padding.WithIterable(VisitRightPadded(control.Padding.Iterable, CsRightPadded.Location.FOR_EACH_VARIABLE_LOOP_CONTROL_ITERABLE, p)!);
        return control;
    }

    public virtual J? VisitArgument(Cs.Argument argument, P p)
    {
        argument = argument.WithPrefix(VisitSpace(argument.Prefix, CsSpace.Location.ARGUMENT_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(argument, p);
        if (tempExpression is not Cs.Argument)
        {
            return tempExpression;
        }
        argument = (Cs.Argument) tempExpression;
        argument = argument.WithMarkers(VisitMarkers(argument.Markers, p));
        argument = argument.Padding.WithNameColumn(argument.Padding.NameColumn == null ? null : VisitRightPadded(argument.Padding.NameColumn, CsRightPadded.Location.ARGUMENT_NAME_COLUMN, p));
        argument = argument.WithRefKindKeyword(VisitAndCast<Cs.Keyword>(argument.RefKindKeyword, p));
        argument = argument.WithExpression(VisitAndCast<Expression>(argument.Expression, p)!);
        return argument;
    }

    public virtual J? VisitAnnotatedStatement(Cs.AnnotatedStatement annotatedStatement, P p)
    {
        annotatedStatement = annotatedStatement.WithPrefix(VisitSpace(annotatedStatement.Prefix, CsSpace.Location.ANNOTATED_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(annotatedStatement, p);
        if (tempStatement is not Cs.AnnotatedStatement)
        {
            return tempStatement;
        }
        annotatedStatement = (Cs.AnnotatedStatement) tempStatement;
        annotatedStatement = annotatedStatement.WithMarkers(VisitMarkers(annotatedStatement.Markers, p));
        annotatedStatement = annotatedStatement.WithAttributeLists(annotatedStatement.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        annotatedStatement = annotatedStatement.WithStatement(VisitAndCast<Statement>(annotatedStatement.Statement, p)!);
        return annotatedStatement;
    }

    public virtual J? VisitArrayRankSpecifier(Cs.ArrayRankSpecifier arrayRankSpecifier, P p)
    {
        arrayRankSpecifier = arrayRankSpecifier.WithPrefix(VisitSpace(arrayRankSpecifier.Prefix, CsSpace.Location.ARRAY_RANK_SPECIFIER_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(arrayRankSpecifier, p);
        if (tempExpression is not Cs.ArrayRankSpecifier)
        {
            return tempExpression;
        }
        arrayRankSpecifier = (Cs.ArrayRankSpecifier) tempExpression;
        arrayRankSpecifier = arrayRankSpecifier.WithMarkers(VisitMarkers(arrayRankSpecifier.Markers, p));
        arrayRankSpecifier = arrayRankSpecifier.Padding.WithSizes(VisitContainer(arrayRankSpecifier.Padding.Sizes, CsContainer.Location.ARRAY_RANK_SPECIFIER_SIZES, p)!);
        return arrayRankSpecifier;
    }

    public virtual J? VisitAssignmentOperation(Cs.AssignmentOperation assignmentOperation, P p)
    {
        assignmentOperation = assignmentOperation.WithPrefix(VisitSpace(assignmentOperation.Prefix, CsSpace.Location.ASSIGNMENT_OPERATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(assignmentOperation, p);
        if (tempStatement is not Cs.AssignmentOperation)
        {
            return tempStatement;
        }
        assignmentOperation = (Cs.AssignmentOperation) tempStatement;
        var tempExpression = (Expression) VisitExpression(assignmentOperation, p);
        if (tempExpression is not Cs.AssignmentOperation)
        {
            return tempExpression;
        }
        assignmentOperation = (Cs.AssignmentOperation) tempExpression;
        assignmentOperation = assignmentOperation.WithMarkers(VisitMarkers(assignmentOperation.Markers, p));
        assignmentOperation = assignmentOperation.WithVariable(VisitAndCast<Expression>(assignmentOperation.Variable, p)!);
        assignmentOperation = assignmentOperation.Padding.WithOperator(VisitLeftPadded(assignmentOperation.Padding.Operator, CsLeftPadded.Location.ASSIGNMENT_OPERATION_OPERATOR, p)!);
        assignmentOperation = assignmentOperation.WithAssignment(VisitAndCast<Expression>(assignmentOperation.Assignment, p)!);
        return assignmentOperation;
    }

    public virtual J? VisitAttributeList(Cs.AttributeList attributeList, P p)
    {
        attributeList = attributeList.WithPrefix(VisitSpace(attributeList.Prefix, CsSpace.Location.ATTRIBUTE_LIST_PREFIX, p)!);
        attributeList = attributeList.WithMarkers(VisitMarkers(attributeList.Markers, p));
        attributeList = attributeList.Padding.WithTarget(attributeList.Padding.Target == null ? null : VisitRightPadded(attributeList.Padding.Target, CsRightPadded.Location.ATTRIBUTE_LIST_TARGET, p));
        attributeList = attributeList.Padding.WithAttributes(attributeList.Padding.Attributes.Map(el => VisitRightPadded(el, CsRightPadded.Location.ATTRIBUTE_LIST_ATTRIBUTES, p)));
        return attributeList;
    }

    public virtual J? VisitAwaitExpression(Cs.AwaitExpression awaitExpression, P p)
    {
        awaitExpression = awaitExpression.WithPrefix(VisitSpace(awaitExpression.Prefix, CsSpace.Location.AWAIT_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(awaitExpression, p);
        if (tempExpression is not Cs.AwaitExpression)
        {
            return tempExpression;
        }
        awaitExpression = (Cs.AwaitExpression) tempExpression;
        awaitExpression = awaitExpression.WithMarkers(VisitMarkers(awaitExpression.Markers, p));
        awaitExpression = awaitExpression.WithExpression(VisitAndCast<Expression>(awaitExpression.Expression, p)!);
        return awaitExpression;
    }

    public virtual J? VisitBinary(Cs.Binary binary, P p)
    {
        binary = binary.WithPrefix(VisitSpace(binary.Prefix, CsSpace.Location.BINARY_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(binary, p);
        if (tempExpression is not Cs.Binary)
        {
            return tempExpression;
        }
        binary = (Cs.Binary) tempExpression;
        binary = binary.WithMarkers(VisitMarkers(binary.Markers, p));
        binary = binary.WithLeft(VisitAndCast<Expression>(binary.Left, p)!);
        binary = binary.Padding.WithOperator(VisitLeftPadded(binary.Padding.Operator, CsLeftPadded.Location.BINARY_OPERATOR, p)!);
        binary = binary.WithRight(VisitAndCast<Expression>(binary.Right, p)!);
        return binary;
    }

    public virtual J? VisitBlockScopeNamespaceDeclaration(Cs.BlockScopeNamespaceDeclaration blockScopeNamespaceDeclaration, P p)
    {
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.WithPrefix(VisitSpace(blockScopeNamespaceDeclaration.Prefix, CsSpace.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(blockScopeNamespaceDeclaration, p);
        if (tempStatement is not Cs.BlockScopeNamespaceDeclaration)
        {
            return tempStatement;
        }
        blockScopeNamespaceDeclaration = (Cs.BlockScopeNamespaceDeclaration) tempStatement;
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.WithMarkers(VisitMarkers(blockScopeNamespaceDeclaration.Markers, p));
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.Padding.WithName(VisitRightPadded(blockScopeNamespaceDeclaration.Padding.Name, CsRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_NAME, p)!);
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.Padding.WithExterns(blockScopeNamespaceDeclaration.Padding.Externs.Map(el => VisitRightPadded(el, CsRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_EXTERNS, p)));
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.Padding.WithUsings(blockScopeNamespaceDeclaration.Padding.Usings.Map(el => VisitRightPadded(el, CsRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_USINGS, p)));
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.Padding.WithMembers(blockScopeNamespaceDeclaration.Padding.Members.Map(el => VisitRightPadded(el, CsRightPadded.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_MEMBERS, p)));
        blockScopeNamespaceDeclaration = blockScopeNamespaceDeclaration.WithEnd(VisitSpace(blockScopeNamespaceDeclaration.End, CsSpace.Location.BLOCK_SCOPE_NAMESPACE_DECLARATION_END, p)!);
        return blockScopeNamespaceDeclaration;
    }

    public virtual J? VisitCollectionExpression(Cs.CollectionExpression collectionExpression, P p)
    {
        collectionExpression = collectionExpression.WithPrefix(VisitSpace(collectionExpression.Prefix, CsSpace.Location.COLLECTION_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(collectionExpression, p);
        if (tempExpression is not Cs.CollectionExpression)
        {
            return tempExpression;
        }
        collectionExpression = (Cs.CollectionExpression) tempExpression;
        collectionExpression = collectionExpression.WithMarkers(VisitMarkers(collectionExpression.Markers, p));
        collectionExpression = collectionExpression.Padding.WithElements(collectionExpression.Padding.Elements.Map(el => VisitRightPadded(el, CsRightPadded.Location.COLLECTION_EXPRESSION_ELEMENTS, p)));
        return collectionExpression;
    }

    public virtual J? VisitExpressionStatement(Cs.ExpressionStatement expressionStatement, P p)
    {
        expressionStatement = expressionStatement.WithPrefix(VisitSpace(expressionStatement.Prefix, CsSpace.Location.EXPRESSION_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(expressionStatement, p);
        if (tempStatement is not Cs.ExpressionStatement)
        {
            return tempStatement;
        }
        expressionStatement = (Cs.ExpressionStatement) tempStatement;
        expressionStatement = expressionStatement.WithMarkers(VisitMarkers(expressionStatement.Markers, p));
        expressionStatement = expressionStatement.WithExpression(VisitAndCast<Expression>(expressionStatement.Expression, p)!);
        return expressionStatement;
    }

    public virtual J? VisitExternAlias(Cs.ExternAlias externAlias, P p)
    {
        externAlias = externAlias.WithPrefix(VisitSpace(externAlias.Prefix, CsSpace.Location.EXTERN_ALIAS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(externAlias, p);
        if (tempStatement is not Cs.ExternAlias)
        {
            return tempStatement;
        }
        externAlias = (Cs.ExternAlias) tempStatement;
        externAlias = externAlias.WithMarkers(VisitMarkers(externAlias.Markers, p));
        externAlias = externAlias.Padding.WithIdentifier(VisitLeftPadded(externAlias.Padding.Identifier, CsLeftPadded.Location.EXTERN_ALIAS_IDENTIFIER, p)!);
        return externAlias;
    }

    public virtual J? VisitFileScopeNamespaceDeclaration(Cs.FileScopeNamespaceDeclaration fileScopeNamespaceDeclaration, P p)
    {
        fileScopeNamespaceDeclaration = fileScopeNamespaceDeclaration.WithPrefix(VisitSpace(fileScopeNamespaceDeclaration.Prefix, CsSpace.Location.FILE_SCOPE_NAMESPACE_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(fileScopeNamespaceDeclaration, p);
        if (tempStatement is not Cs.FileScopeNamespaceDeclaration)
        {
            return tempStatement;
        }
        fileScopeNamespaceDeclaration = (Cs.FileScopeNamespaceDeclaration) tempStatement;
        fileScopeNamespaceDeclaration = fileScopeNamespaceDeclaration.WithMarkers(VisitMarkers(fileScopeNamespaceDeclaration.Markers, p));
        fileScopeNamespaceDeclaration = fileScopeNamespaceDeclaration.Padding.WithName(VisitRightPadded(fileScopeNamespaceDeclaration.Padding.Name, CsRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_NAME, p)!);
        fileScopeNamespaceDeclaration = fileScopeNamespaceDeclaration.Padding.WithExterns(fileScopeNamespaceDeclaration.Padding.Externs.Map(el => VisitRightPadded(el, CsRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_EXTERNS, p)));
        fileScopeNamespaceDeclaration = fileScopeNamespaceDeclaration.Padding.WithUsings(fileScopeNamespaceDeclaration.Padding.Usings.Map(el => VisitRightPadded(el, CsRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_USINGS, p)));
        fileScopeNamespaceDeclaration = fileScopeNamespaceDeclaration.Padding.WithMembers(fileScopeNamespaceDeclaration.Padding.Members.Map(el => VisitRightPadded(el, CsRightPadded.Location.FILE_SCOPE_NAMESPACE_DECLARATION_MEMBERS, p)));
        return fileScopeNamespaceDeclaration;
    }

    public virtual J? VisitInterpolatedString(Cs.InterpolatedString interpolatedString, P p)
    {
        interpolatedString = interpolatedString.WithPrefix(VisitSpace(interpolatedString.Prefix, CsSpace.Location.INTERPOLATED_STRING_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(interpolatedString, p);
        if (tempExpression is not Cs.InterpolatedString)
        {
            return tempExpression;
        }
        interpolatedString = (Cs.InterpolatedString) tempExpression;
        interpolatedString = interpolatedString.WithMarkers(VisitMarkers(interpolatedString.Markers, p));
        interpolatedString = interpolatedString.Padding.WithParts(interpolatedString.Padding.Parts.Map(el => VisitRightPadded(el, CsRightPadded.Location.INTERPOLATED_STRING_PARTS, p)));
        return interpolatedString;
    }

    public virtual J? VisitInterpolation(Cs.Interpolation interpolation, P p)
    {
        interpolation = interpolation.WithPrefix(VisitSpace(interpolation.Prefix, CsSpace.Location.INTERPOLATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(interpolation, p);
        if (tempExpression is not Cs.Interpolation)
        {
            return tempExpression;
        }
        interpolation = (Cs.Interpolation) tempExpression;
        interpolation = interpolation.WithMarkers(VisitMarkers(interpolation.Markers, p));
        interpolation = interpolation.Padding.WithExpression(VisitRightPadded(interpolation.Padding.Expression, CsRightPadded.Location.INTERPOLATION_EXPRESSION, p)!);
        interpolation = interpolation.Padding.WithAlignment(interpolation.Padding.Alignment == null ? null : VisitRightPadded(interpolation.Padding.Alignment, CsRightPadded.Location.INTERPOLATION_ALIGNMENT, p));
        interpolation = interpolation.Padding.WithFormat(interpolation.Padding.Format == null ? null : VisitRightPadded(interpolation.Padding.Format, CsRightPadded.Location.INTERPOLATION_FORMAT, p));
        return interpolation;
    }

    public virtual J? VisitNullSafeExpression(Cs.NullSafeExpression nullSafeExpression, P p)
    {
        nullSafeExpression = nullSafeExpression.WithPrefix(VisitSpace(nullSafeExpression.Prefix, CsSpace.Location.NULL_SAFE_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(nullSafeExpression, p);
        if (tempExpression is not Cs.NullSafeExpression)
        {
            return tempExpression;
        }
        nullSafeExpression = (Cs.NullSafeExpression) tempExpression;
        nullSafeExpression = nullSafeExpression.WithMarkers(VisitMarkers(nullSafeExpression.Markers, p));
        nullSafeExpression = nullSafeExpression.Padding.WithExpression(VisitRightPadded(nullSafeExpression.Padding.Expression, CsRightPadded.Location.NULL_SAFE_EXPRESSION_EXPRESSION, p)!);
        return nullSafeExpression;
    }

    public virtual J? VisitStatementExpression(Cs.StatementExpression statementExpression, P p)
    {
        statementExpression = statementExpression.WithPrefix(VisitSpace(statementExpression.Prefix, CsSpace.Location.STATEMENT_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(statementExpression, p);
        if (tempExpression is not Cs.StatementExpression)
        {
            return tempExpression;
        }
        statementExpression = (Cs.StatementExpression) tempExpression;
        statementExpression = statementExpression.WithMarkers(VisitMarkers(statementExpression.Markers, p));
        statementExpression = statementExpression.WithStatement(VisitAndCast<Statement>(statementExpression.Statement, p)!);
        return statementExpression;
    }

    public virtual J? VisitUsingDirective(Cs.UsingDirective usingDirective, P p)
    {
        usingDirective = usingDirective.WithPrefix(VisitSpace(usingDirective.Prefix, CsSpace.Location.USING_DIRECTIVE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(usingDirective, p);
        if (tempStatement is not Cs.UsingDirective)
        {
            return tempStatement;
        }
        usingDirective = (Cs.UsingDirective) tempStatement;
        usingDirective = usingDirective.WithMarkers(VisitMarkers(usingDirective.Markers, p));
        usingDirective = usingDirective.Padding.WithGlobal(VisitRightPadded(usingDirective.Padding.Global, CsRightPadded.Location.USING_DIRECTIVE_GLOBAL, p)!);
        usingDirective = usingDirective.Padding.WithStatic(VisitLeftPadded(usingDirective.Padding.Static, CsLeftPadded.Location.USING_DIRECTIVE_STATIC, p)!);
        usingDirective = usingDirective.Padding.WithUnsafe(VisitLeftPadded(usingDirective.Padding.Unsafe, CsLeftPadded.Location.USING_DIRECTIVE_UNSAFE, p)!);
        usingDirective = usingDirective.Padding.WithAlias(usingDirective.Padding.Alias == null ? null : VisitRightPadded(usingDirective.Padding.Alias, CsRightPadded.Location.USING_DIRECTIVE_ALIAS, p));
        usingDirective = usingDirective.WithNamespaceOrType(VisitAndCast<TypeTree>(usingDirective.NamespaceOrType, p)!);
        return usingDirective;
    }

    public virtual J? VisitPropertyDeclaration(Cs.PropertyDeclaration propertyDeclaration, P p)
    {
        propertyDeclaration = propertyDeclaration.WithPrefix(VisitSpace(propertyDeclaration.Prefix, CsSpace.Location.PROPERTY_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(propertyDeclaration, p);
        if (tempStatement is not Cs.PropertyDeclaration)
        {
            return tempStatement;
        }
        propertyDeclaration = (Cs.PropertyDeclaration) tempStatement;
        propertyDeclaration = propertyDeclaration.WithMarkers(VisitMarkers(propertyDeclaration.Markers, p));
        propertyDeclaration = propertyDeclaration.WithAttributeLists(propertyDeclaration.AttributeLists.Map(el => (Cs.AttributeList?)Visit(el, p)));
        propertyDeclaration = propertyDeclaration.WithModifiers(propertyDeclaration.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        propertyDeclaration = propertyDeclaration.WithTypeExpression(VisitAndCast<TypeTree>(propertyDeclaration.TypeExpression, p)!);
        propertyDeclaration = propertyDeclaration.Padding.WithInterfaceSpecifier(propertyDeclaration.Padding.InterfaceSpecifier == null ? null : VisitRightPadded(propertyDeclaration.Padding.InterfaceSpecifier, CsRightPadded.Location.PROPERTY_DECLARATION_INTERFACE_SPECIFIER, p));
        propertyDeclaration = propertyDeclaration.WithName(VisitAndCast<J.Identifier>(propertyDeclaration.Name, p)!);
        propertyDeclaration = propertyDeclaration.WithAccessors(VisitAndCast<J.Block>(propertyDeclaration.Accessors, p)!);
        propertyDeclaration = propertyDeclaration.Padding.WithInitializer(propertyDeclaration.Padding.Initializer == null ? null : VisitLeftPadded(propertyDeclaration.Padding.Initializer, CsLeftPadded.Location.PROPERTY_DECLARATION_INITIALIZER, p));
        return propertyDeclaration;
    }

    public virtual J? VisitKeyword(Cs.Keyword keyword, P p)
    {
        keyword = keyword.WithPrefix(VisitSpace(keyword.Prefix, CsSpace.Location.KEYWORD_PREFIX, p)!);
        keyword = keyword.WithMarkers(VisitMarkers(keyword.Markers, p));
        return keyword;
    }

    public virtual J? VisitLambda(Cs.Lambda lambda, P p)
    {
        lambda = lambda.WithPrefix(VisitSpace(lambda.Prefix, CsSpace.Location.LAMBDA_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(lambda, p);
        if (tempStatement is not Cs.Lambda)
        {
            return tempStatement;
        }
        lambda = (Cs.Lambda) tempStatement;
        var tempExpression = (Expression) VisitExpression(lambda, p);
        if (tempExpression is not Cs.Lambda)
        {
            return tempExpression;
        }
        lambda = (Cs.Lambda) tempExpression;
        lambda = lambda.WithMarkers(VisitMarkers(lambda.Markers, p));
        lambda = lambda.WithLambdaExpression(VisitAndCast<J.Lambda>(lambda.LambdaExpression, p)!);
        lambda = lambda.WithModifiers(lambda.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        return lambda;
    }

    public virtual J? VisitClassDeclaration(Cs.ClassDeclaration classDeclaration, P p)
    {
        classDeclaration = classDeclaration.WithPrefix(VisitSpace(classDeclaration.Prefix, CsSpace.Location.CLASS_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(classDeclaration, p);
        if (tempStatement is not Cs.ClassDeclaration)
        {
            return tempStatement;
        }
        classDeclaration = (Cs.ClassDeclaration) tempStatement;
        classDeclaration = classDeclaration.WithMarkers(VisitMarkers(classDeclaration.Markers, p));
        classDeclaration = classDeclaration.WithClassDeclarationCore(VisitAndCast<J.ClassDeclaration>(classDeclaration.ClassDeclarationCore, p)!);
        classDeclaration = classDeclaration.Padding.WithTypeParameterConstraintClauses(VisitContainer(classDeclaration.Padding.TypeParameterConstraintClauses, CsContainer.Location.CLASS_DECLARATION_TYPE_PARAMETER_CONSTRAINT_CLAUSES, p)!);
        return classDeclaration;
    }

    public virtual J? VisitMethodDeclaration(Cs.MethodDeclaration methodDeclaration, P p)
    {
        methodDeclaration = methodDeclaration.WithPrefix(VisitSpace(methodDeclaration.Prefix, CsSpace.Location.METHOD_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(methodDeclaration, p);
        if (tempStatement is not Cs.MethodDeclaration)
        {
            return tempStatement;
        }
        methodDeclaration = (Cs.MethodDeclaration) tempStatement;
        methodDeclaration = methodDeclaration.WithMarkers(VisitMarkers(methodDeclaration.Markers, p));
        methodDeclaration = methodDeclaration.WithMethodDeclarationCore(VisitAndCast<J.MethodDeclaration>(methodDeclaration.MethodDeclarationCore, p)!);
        methodDeclaration = methodDeclaration.Padding.WithTypeParameterConstraintClauses(VisitContainer(methodDeclaration.Padding.TypeParameterConstraintClauses, CsContainer.Location.METHOD_DECLARATION_TYPE_PARAMETER_CONSTRAINT_CLAUSES, p)!);
        return methodDeclaration;
    }

    public virtual J? VisitUsingStatement(Cs.UsingStatement usingStatement, P p)
    {
        usingStatement = usingStatement.WithPrefix(VisitSpace(usingStatement.Prefix, CsSpace.Location.USING_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(usingStatement, p);
        if (tempStatement is not Cs.UsingStatement)
        {
            return tempStatement;
        }
        usingStatement = (Cs.UsingStatement) tempStatement;
        usingStatement = usingStatement.WithMarkers(VisitMarkers(usingStatement.Markers, p));
        usingStatement = usingStatement.WithAwaitKeyword(VisitAndCast<Cs.Keyword>(usingStatement.AwaitKeyword, p));
        usingStatement = usingStatement.Padding.WithExpression(VisitContainer(usingStatement.Padding.Expression, CsContainer.Location.USING_STATEMENT_EXPRESSION, p)!);
        usingStatement = usingStatement.WithStatement(VisitAndCast<Statement>(usingStatement.Statement, p)!);
        return usingStatement;
    }

    public virtual J? VisitTypeParameterConstraintClause(Cs.TypeParameterConstraintClause typeParameterConstraintClause, P p)
    {
        typeParameterConstraintClause = typeParameterConstraintClause.WithPrefix(VisitSpace(typeParameterConstraintClause.Prefix, CsSpace.Location.TYPE_PARAMETER_CONSTRAINT_CLAUSE_PREFIX, p)!);
        typeParameterConstraintClause = typeParameterConstraintClause.WithMarkers(VisitMarkers(typeParameterConstraintClause.Markers, p));
        typeParameterConstraintClause = typeParameterConstraintClause.Padding.WithTypeParameter(VisitRightPadded(typeParameterConstraintClause.Padding.TypeParameter, CsRightPadded.Location.TYPE_PARAMETER_CONSTRAINT_CLAUSE_TYPE_PARAMETER, p)!);
        typeParameterConstraintClause = typeParameterConstraintClause.Padding.WithTypeParameterConstraints(VisitContainer(typeParameterConstraintClause.Padding.TypeParameterConstraints, CsContainer.Location.TYPE_PARAMETER_CONSTRAINT_CLAUSE_TYPE_PARAMETER_CONSTRAINTS, p)!);
        return typeParameterConstraintClause;
    }

    public virtual J? VisitTypeConstraint(Cs.TypeConstraint typeConstraint, P p)
    {
        typeConstraint = typeConstraint.WithPrefix(VisitSpace(typeConstraint.Prefix, CsSpace.Location.TYPE_CONSTRAINT_PREFIX, p)!);
        typeConstraint = typeConstraint.WithMarkers(VisitMarkers(typeConstraint.Markers, p));
        typeConstraint = typeConstraint.WithTypeExpression(VisitAndCast<TypeTree>(typeConstraint.TypeExpression, p)!);
        return typeConstraint;
    }

    public virtual J? VisitAllowsConstraintClause(Cs.AllowsConstraintClause allowsConstraintClause, P p)
    {
        allowsConstraintClause = allowsConstraintClause.WithPrefix(VisitSpace(allowsConstraintClause.Prefix, CsSpace.Location.ALLOWS_CONSTRAINT_CLAUSE_PREFIX, p)!);
        allowsConstraintClause = allowsConstraintClause.WithMarkers(VisitMarkers(allowsConstraintClause.Markers, p));
        allowsConstraintClause = allowsConstraintClause.Padding.WithExpressions(VisitContainer(allowsConstraintClause.Padding.Expressions, CsContainer.Location.ALLOWS_CONSTRAINT_CLAUSE_EXPRESSIONS, p)!);
        return allowsConstraintClause;
    }

    public virtual J? VisitRefStructConstraint(Cs.RefStructConstraint refStructConstraint, P p)
    {
        refStructConstraint = refStructConstraint.WithPrefix(VisitSpace(refStructConstraint.Prefix, CsSpace.Location.REF_STRUCT_CONSTRAINT_PREFIX, p)!);
        refStructConstraint = refStructConstraint.WithMarkers(VisitMarkers(refStructConstraint.Markers, p));
        return refStructConstraint;
    }

    public virtual J? VisitClassOrStructConstraint(Cs.ClassOrStructConstraint classOrStructConstraint, P p)
    {
        classOrStructConstraint = classOrStructConstraint.WithPrefix(VisitSpace(classOrStructConstraint.Prefix, CsSpace.Location.CLASS_OR_STRUCT_CONSTRAINT_PREFIX, p)!);
        classOrStructConstraint = classOrStructConstraint.WithMarkers(VisitMarkers(classOrStructConstraint.Markers, p));
        return classOrStructConstraint;
    }

    public virtual J? VisitConstructorConstraint(Cs.ConstructorConstraint constructorConstraint, P p)
    {
        constructorConstraint = constructorConstraint.WithPrefix(VisitSpace(constructorConstraint.Prefix, CsSpace.Location.CONSTRUCTOR_CONSTRAINT_PREFIX, p)!);
        constructorConstraint = constructorConstraint.WithMarkers(VisitMarkers(constructorConstraint.Markers, p));
        return constructorConstraint;
    }

    public virtual J? VisitDefaultConstraint(Cs.DefaultConstraint defaultConstraint, P p)
    {
        defaultConstraint = defaultConstraint.WithPrefix(VisitSpace(defaultConstraint.Prefix, CsSpace.Location.DEFAULT_CONSTRAINT_PREFIX, p)!);
        defaultConstraint = defaultConstraint.WithMarkers(VisitMarkers(defaultConstraint.Markers, p));
        return defaultConstraint;
    }

    public virtual J? VisitDeclarationExpression(Cs.DeclarationExpression declarationExpression, P p)
    {
        declarationExpression = declarationExpression.WithPrefix(VisitSpace(declarationExpression.Prefix, CsSpace.Location.DECLARATION_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(declarationExpression, p);
        if (tempExpression is not Cs.DeclarationExpression)
        {
            return tempExpression;
        }
        declarationExpression = (Cs.DeclarationExpression) tempExpression;
        declarationExpression = declarationExpression.WithMarkers(VisitMarkers(declarationExpression.Markers, p));
        declarationExpression = declarationExpression.WithTypeExpression(VisitAndCast<TypeTree>(declarationExpression.TypeExpression, p));
        declarationExpression = declarationExpression.WithVariables(VisitAndCast<Cs.VariableDesignation>(declarationExpression.Variables, p)!);
        return declarationExpression;
    }

    public virtual J? VisitSingleVariableDesignation(Cs.SingleVariableDesignation singleVariableDesignation, P p)
    {
        singleVariableDesignation = singleVariableDesignation.WithPrefix(VisitSpace(singleVariableDesignation.Prefix, CsSpace.Location.SINGLE_VARIABLE_DESIGNATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(singleVariableDesignation, p);
        if (tempExpression is not Cs.SingleVariableDesignation)
        {
            return tempExpression;
        }
        singleVariableDesignation = (Cs.SingleVariableDesignation) tempExpression;
        singleVariableDesignation = singleVariableDesignation.WithMarkers(VisitMarkers(singleVariableDesignation.Markers, p));
        singleVariableDesignation = singleVariableDesignation.WithName(VisitAndCast<J.Identifier>(singleVariableDesignation.Name, p)!);
        return singleVariableDesignation;
    }

    public virtual J? VisitParenthesizedVariableDesignation(Cs.ParenthesizedVariableDesignation parenthesizedVariableDesignation, P p)
    {
        parenthesizedVariableDesignation = parenthesizedVariableDesignation.WithPrefix(VisitSpace(parenthesizedVariableDesignation.Prefix, CsSpace.Location.PARENTHESIZED_VARIABLE_DESIGNATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(parenthesizedVariableDesignation, p);
        if (tempExpression is not Cs.ParenthesizedVariableDesignation)
        {
            return tempExpression;
        }
        parenthesizedVariableDesignation = (Cs.ParenthesizedVariableDesignation) tempExpression;
        parenthesizedVariableDesignation = parenthesizedVariableDesignation.WithMarkers(VisitMarkers(parenthesizedVariableDesignation.Markers, p));
        parenthesizedVariableDesignation = parenthesizedVariableDesignation.Padding.WithVariables(VisitContainer(parenthesizedVariableDesignation.Padding.Variables, CsContainer.Location.PARENTHESIZED_VARIABLE_DESIGNATION_VARIABLES, p)!);
        return parenthesizedVariableDesignation;
    }

    public virtual J? VisitDiscardVariableDesignation(Cs.DiscardVariableDesignation discardVariableDesignation, P p)
    {
        discardVariableDesignation = discardVariableDesignation.WithPrefix(VisitSpace(discardVariableDesignation.Prefix, CsSpace.Location.DISCARD_VARIABLE_DESIGNATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(discardVariableDesignation, p);
        if (tempExpression is not Cs.DiscardVariableDesignation)
        {
            return tempExpression;
        }
        discardVariableDesignation = (Cs.DiscardVariableDesignation) tempExpression;
        discardVariableDesignation = discardVariableDesignation.WithMarkers(VisitMarkers(discardVariableDesignation.Markers, p));
        discardVariableDesignation = discardVariableDesignation.WithDiscard(VisitAndCast<J.Identifier>(discardVariableDesignation.Discard, p)!);
        return discardVariableDesignation;
    }

    public virtual J? VisitTupleExpression(Cs.TupleExpression tupleExpression, P p)
    {
        tupleExpression = tupleExpression.WithPrefix(VisitSpace(tupleExpression.Prefix, CsSpace.Location.TUPLE_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(tupleExpression, p);
        if (tempExpression is not Cs.TupleExpression)
        {
            return tempExpression;
        }
        tupleExpression = (Cs.TupleExpression) tempExpression;
        tupleExpression = tupleExpression.WithMarkers(VisitMarkers(tupleExpression.Markers, p));
        tupleExpression = tupleExpression.Padding.WithArguments(VisitContainer(tupleExpression.Padding.Arguments, CsContainer.Location.TUPLE_EXPRESSION_ARGUMENTS, p)!);
        return tupleExpression;
    }

    public virtual J? VisitConstructor(Cs.Constructor constructor, P p)
    {
        constructor = constructor.WithPrefix(VisitSpace(constructor.Prefix, CsSpace.Location.CONSTRUCTOR_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(constructor, p);
        if (tempStatement is not Cs.Constructor)
        {
            return tempStatement;
        }
        constructor = (Cs.Constructor) tempStatement;
        constructor = constructor.WithMarkers(VisitMarkers(constructor.Markers, p));
        constructor = constructor.WithInitializer(VisitAndCast<Cs.ConstructorInitializer>(constructor.Initializer, p));
        constructor = constructor.WithConstructorCore(VisitAndCast<J.MethodDeclaration>(constructor.ConstructorCore, p)!);
        return constructor;
    }

    public virtual J? VisitDestructorDeclaration(Cs.DestructorDeclaration destructorDeclaration, P p)
    {
        destructorDeclaration = destructorDeclaration.WithPrefix(VisitSpace(destructorDeclaration.Prefix, CsSpace.Location.DESTRUCTOR_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(destructorDeclaration, p);
        if (tempStatement is not Cs.DestructorDeclaration)
        {
            return tempStatement;
        }
        destructorDeclaration = (Cs.DestructorDeclaration) tempStatement;
        destructorDeclaration = destructorDeclaration.WithMarkers(VisitMarkers(destructorDeclaration.Markers, p));
        destructorDeclaration = destructorDeclaration.WithInitializer(VisitAndCast<Cs.ConstructorInitializer>(destructorDeclaration.Initializer, p));
        destructorDeclaration = destructorDeclaration.WithConstructorCore(VisitAndCast<J.MethodDeclaration>(destructorDeclaration.ConstructorCore, p)!);
        return destructorDeclaration;
    }

    public virtual J? VisitUnary(Cs.Unary unary, P p)
    {
        unary = unary.WithPrefix(VisitSpace(unary.Prefix, CsSpace.Location.UNARY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(unary, p);
        if (tempStatement is not Cs.Unary)
        {
            return tempStatement;
        }
        unary = (Cs.Unary) tempStatement;
        var tempExpression = (Expression) VisitExpression(unary, p);
        if (tempExpression is not Cs.Unary)
        {
            return tempExpression;
        }
        unary = (Cs.Unary) tempExpression;
        unary = unary.WithMarkers(VisitMarkers(unary.Markers, p));
        unary = unary.Padding.WithOperator(VisitLeftPadded(unary.Padding.Operator, CsLeftPadded.Location.UNARY_OPERATOR, p)!);
        unary = unary.WithExpression(VisitAndCast<Expression>(unary.Expression, p)!);
        return unary;
    }

    public virtual J? VisitConstructorInitializer(Cs.ConstructorInitializer constructorInitializer, P p)
    {
        constructorInitializer = constructorInitializer.WithPrefix(VisitSpace(constructorInitializer.Prefix, CsSpace.Location.CONSTRUCTOR_INITIALIZER_PREFIX, p)!);
        constructorInitializer = constructorInitializer.WithMarkers(VisitMarkers(constructorInitializer.Markers, p));
        constructorInitializer = constructorInitializer.WithKeyword(VisitAndCast<Cs.Keyword>(constructorInitializer.Keyword, p)!);
        constructorInitializer = constructorInitializer.Padding.WithArguments(VisitContainer(constructorInitializer.Padding.Arguments, CsContainer.Location.CONSTRUCTOR_INITIALIZER_ARGUMENTS, p)!);
        return constructorInitializer;
    }

    public virtual J? VisitTupleType(Cs.TupleType tupleType, P p)
    {
        tupleType = tupleType.WithPrefix(VisitSpace(tupleType.Prefix, CsSpace.Location.TUPLE_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(tupleType, p);
        if (tempExpression is not Cs.TupleType)
        {
            return tempExpression;
        }
        tupleType = (Cs.TupleType) tempExpression;
        tupleType = tupleType.WithMarkers(VisitMarkers(tupleType.Markers, p));
        tupleType = tupleType.Padding.WithElements(VisitContainer(tupleType.Padding.Elements, CsContainer.Location.TUPLE_TYPE_ELEMENTS, p)!);
        return tupleType;
    }

    public virtual J? VisitTupleElement(Cs.TupleElement tupleElement, P p)
    {
        tupleElement = tupleElement.WithPrefix(VisitSpace(tupleElement.Prefix, CsSpace.Location.TUPLE_ELEMENT_PREFIX, p)!);
        tupleElement = tupleElement.WithMarkers(VisitMarkers(tupleElement.Markers, p));
        tupleElement = tupleElement.WithType(VisitAndCast<TypeTree>(tupleElement.Type, p)!);
        tupleElement = tupleElement.WithName(VisitAndCast<J.Identifier>(tupleElement.Name, p));
        return tupleElement;
    }

    public virtual J? VisitNewClass(Cs.NewClass newClass, P p)
    {
        newClass = newClass.WithPrefix(VisitSpace(newClass.Prefix, CsSpace.Location.NEW_CLASS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(newClass, p);
        if (tempStatement is not Cs.NewClass)
        {
            return tempStatement;
        }
        newClass = (Cs.NewClass) tempStatement;
        var tempExpression = (Expression) VisitExpression(newClass, p);
        if (tempExpression is not Cs.NewClass)
        {
            return tempExpression;
        }
        newClass = (Cs.NewClass) tempExpression;
        newClass = newClass.WithMarkers(VisitMarkers(newClass.Markers, p));
        newClass = newClass.WithNewClassCore(VisitAndCast<J.NewClass>(newClass.NewClassCore, p)!);
        newClass = newClass.WithInitializer(VisitAndCast<Cs.InitializerExpression>(newClass.Initializer, p));
        return newClass;
    }

    public virtual J? VisitInitializerExpression(Cs.InitializerExpression initializerExpression, P p)
    {
        initializerExpression = initializerExpression.WithPrefix(VisitSpace(initializerExpression.Prefix, CsSpace.Location.INITIALIZER_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(initializerExpression, p);
        if (tempExpression is not Cs.InitializerExpression)
        {
            return tempExpression;
        }
        initializerExpression = (Cs.InitializerExpression) tempExpression;
        initializerExpression = initializerExpression.WithMarkers(VisitMarkers(initializerExpression.Markers, p));
        initializerExpression = initializerExpression.Padding.WithExpressions(VisitContainer(initializerExpression.Padding.Expressions, CsContainer.Location.INITIALIZER_EXPRESSION_EXPRESSIONS, p)!);
        return initializerExpression;
    }

    public virtual J? VisitImplicitElementAccess(Cs.ImplicitElementAccess implicitElementAccess, P p)
    {
        implicitElementAccess = implicitElementAccess.WithPrefix(VisitSpace(implicitElementAccess.Prefix, CsSpace.Location.IMPLICIT_ELEMENT_ACCESS_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(implicitElementAccess, p);
        if (tempExpression is not Cs.ImplicitElementAccess)
        {
            return tempExpression;
        }
        implicitElementAccess = (Cs.ImplicitElementAccess) tempExpression;
        implicitElementAccess = implicitElementAccess.WithMarkers(VisitMarkers(implicitElementAccess.Markers, p));
        implicitElementAccess = implicitElementAccess.Padding.WithArgumentList(VisitContainer(implicitElementAccess.Padding.ArgumentList, CsContainer.Location.IMPLICIT_ELEMENT_ACCESS_ARGUMENT_LIST, p)!);
        return implicitElementAccess;
    }

    public virtual J? VisitYield(Cs.Yield yield, P p)
    {
        yield = yield.WithPrefix(VisitSpace(yield.Prefix, CsSpace.Location.YIELD_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(yield, p);
        if (tempStatement is not Cs.Yield)
        {
            return tempStatement;
        }
        yield = (Cs.Yield) tempStatement;
        yield = yield.WithMarkers(VisitMarkers(yield.Markers, p));
        yield = yield.WithReturnOrBreakKeyword(VisitAndCast<Cs.Keyword>(yield.ReturnOrBreakKeyword, p)!);
        yield = yield.WithExpression(VisitAndCast<Expression>(yield.Expression, p));
        return yield;
    }

    public virtual J? VisitDefaultExpression(Cs.DefaultExpression defaultExpression, P p)
    {
        defaultExpression = defaultExpression.WithPrefix(VisitSpace(defaultExpression.Prefix, CsSpace.Location.DEFAULT_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(defaultExpression, p);
        if (tempExpression is not Cs.DefaultExpression)
        {
            return tempExpression;
        }
        defaultExpression = (Cs.DefaultExpression) tempExpression;
        defaultExpression = defaultExpression.WithMarkers(VisitMarkers(defaultExpression.Markers, p));
        defaultExpression = defaultExpression.Padding.WithTypeOperator(defaultExpression.Padding.TypeOperator == null ? null : VisitContainer(defaultExpression.Padding.TypeOperator, CsContainer.Location.DEFAULT_EXPRESSION_TYPE_OPERATOR, p));
        return defaultExpression;
    }

    public virtual J? VisitIsPattern(Cs.IsPattern isPattern, P p)
    {
        isPattern = isPattern.WithPrefix(VisitSpace(isPattern.Prefix, CsSpace.Location.IS_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(isPattern, p);
        if (tempExpression is not Cs.IsPattern)
        {
            return tempExpression;
        }
        isPattern = (Cs.IsPattern) tempExpression;
        isPattern = isPattern.WithMarkers(VisitMarkers(isPattern.Markers, p));
        isPattern = isPattern.WithExpression(VisitAndCast<Expression>(isPattern.Expression, p)!);
        isPattern = isPattern.Padding.WithPattern(VisitLeftPadded(isPattern.Padding.Pattern, CsLeftPadded.Location.IS_PATTERN_PATTERN, p)!);
        return isPattern;
    }

    public virtual J? VisitUnaryPattern(Cs.UnaryPattern unaryPattern, P p)
    {
        unaryPattern = unaryPattern.WithPrefix(VisitSpace(unaryPattern.Prefix, CsSpace.Location.UNARY_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(unaryPattern, p);
        if (tempExpression is not Cs.UnaryPattern)
        {
            return tempExpression;
        }
        unaryPattern = (Cs.UnaryPattern) tempExpression;
        unaryPattern = unaryPattern.WithMarkers(VisitMarkers(unaryPattern.Markers, p));
        unaryPattern = unaryPattern.WithOperator(VisitAndCast<Cs.Keyword>(unaryPattern.Operator, p)!);
        unaryPattern = unaryPattern.WithPattern(VisitAndCast<Cs.Pattern>(unaryPattern.Pattern, p)!);
        return unaryPattern;
    }

    public virtual J? VisitTypePattern(Cs.TypePattern typePattern, P p)
    {
        typePattern = typePattern.WithPrefix(VisitSpace(typePattern.Prefix, CsSpace.Location.TYPE_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(typePattern, p);
        if (tempExpression is not Cs.TypePattern)
        {
            return tempExpression;
        }
        typePattern = (Cs.TypePattern) tempExpression;
        typePattern = typePattern.WithMarkers(VisitMarkers(typePattern.Markers, p));
        typePattern = typePattern.WithTypeIdentifier(VisitAndCast<TypeTree>(typePattern.TypeIdentifier, p)!);
        typePattern = typePattern.WithDesignation(VisitAndCast<Cs.VariableDesignation>(typePattern.Designation, p));
        return typePattern;
    }

    public virtual J? VisitBinaryPattern(Cs.BinaryPattern binaryPattern, P p)
    {
        binaryPattern = binaryPattern.WithPrefix(VisitSpace(binaryPattern.Prefix, CsSpace.Location.BINARY_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(binaryPattern, p);
        if (tempExpression is not Cs.BinaryPattern)
        {
            return tempExpression;
        }
        binaryPattern = (Cs.BinaryPattern) tempExpression;
        binaryPattern = binaryPattern.WithMarkers(VisitMarkers(binaryPattern.Markers, p));
        binaryPattern = binaryPattern.WithLeft(VisitAndCast<Cs.Pattern>(binaryPattern.Left, p)!);
        binaryPattern = binaryPattern.Padding.WithOperator(VisitLeftPadded(binaryPattern.Padding.Operator, CsLeftPadded.Location.BINARY_PATTERN_OPERATOR, p)!);
        binaryPattern = binaryPattern.WithRight(VisitAndCast<Cs.Pattern>(binaryPattern.Right, p)!);
        return binaryPattern;
    }

    public virtual J? VisitConstantPattern(Cs.ConstantPattern constantPattern, P p)
    {
        constantPattern = constantPattern.WithPrefix(VisitSpace(constantPattern.Prefix, CsSpace.Location.CONSTANT_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(constantPattern, p);
        if (tempExpression is not Cs.ConstantPattern)
        {
            return tempExpression;
        }
        constantPattern = (Cs.ConstantPattern) tempExpression;
        constantPattern = constantPattern.WithMarkers(VisitMarkers(constantPattern.Markers, p));
        constantPattern = constantPattern.WithValue(VisitAndCast<Expression>(constantPattern.Value, p)!);
        return constantPattern;
    }

    public virtual J? VisitDiscardPattern(Cs.DiscardPattern discardPattern, P p)
    {
        discardPattern = discardPattern.WithPrefix(VisitSpace(discardPattern.Prefix, CsSpace.Location.DISCARD_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(discardPattern, p);
        if (tempExpression is not Cs.DiscardPattern)
        {
            return tempExpression;
        }
        discardPattern = (Cs.DiscardPattern) tempExpression;
        discardPattern = discardPattern.WithMarkers(VisitMarkers(discardPattern.Markers, p));
        return discardPattern;
    }

    public virtual J? VisitListPattern(Cs.ListPattern listPattern, P p)
    {
        listPattern = listPattern.WithPrefix(VisitSpace(listPattern.Prefix, CsSpace.Location.LIST_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(listPattern, p);
        if (tempExpression is not Cs.ListPattern)
        {
            return tempExpression;
        }
        listPattern = (Cs.ListPattern) tempExpression;
        listPattern = listPattern.WithMarkers(VisitMarkers(listPattern.Markers, p));
        listPattern = listPattern.Padding.WithPatterns(VisitContainer(listPattern.Padding.Patterns, CsContainer.Location.LIST_PATTERN_PATTERNS, p)!);
        listPattern = listPattern.WithDesignation(VisitAndCast<Cs.VariableDesignation>(listPattern.Designation, p));
        return listPattern;
    }

    public virtual J? VisitParenthesizedPattern(Cs.ParenthesizedPattern parenthesizedPattern, P p)
    {
        parenthesizedPattern = parenthesizedPattern.WithPrefix(VisitSpace(parenthesizedPattern.Prefix, CsSpace.Location.PARENTHESIZED_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(parenthesizedPattern, p);
        if (tempExpression is not Cs.ParenthesizedPattern)
        {
            return tempExpression;
        }
        parenthesizedPattern = (Cs.ParenthesizedPattern) tempExpression;
        parenthesizedPattern = parenthesizedPattern.WithMarkers(VisitMarkers(parenthesizedPattern.Markers, p));
        parenthesizedPattern = parenthesizedPattern.Padding.WithPattern(VisitContainer(parenthesizedPattern.Padding.Pattern, CsContainer.Location.PARENTHESIZED_PATTERN_PATTERN, p)!);
        return parenthesizedPattern;
    }

    public virtual J? VisitRecursivePattern(Cs.RecursivePattern recursivePattern, P p)
    {
        recursivePattern = recursivePattern.WithPrefix(VisitSpace(recursivePattern.Prefix, CsSpace.Location.RECURSIVE_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(recursivePattern, p);
        if (tempExpression is not Cs.RecursivePattern)
        {
            return tempExpression;
        }
        recursivePattern = (Cs.RecursivePattern) tempExpression;
        recursivePattern = recursivePattern.WithMarkers(VisitMarkers(recursivePattern.Markers, p));
        recursivePattern = recursivePattern.WithTypeQualifier(VisitAndCast<TypeTree>(recursivePattern.TypeQualifier, p));
        recursivePattern = recursivePattern.WithPositionalPattern(VisitAndCast<Cs.PositionalPatternClause>(recursivePattern.PositionalPattern, p));
        recursivePattern = recursivePattern.WithPropertyPattern(VisitAndCast<Cs.PropertyPatternClause>(recursivePattern.PropertyPattern, p));
        recursivePattern = recursivePattern.WithDesignation(VisitAndCast<Cs.VariableDesignation>(recursivePattern.Designation, p));
        return recursivePattern;
    }

    public virtual J? VisitVarPattern(Cs.VarPattern varPattern, P p)
    {
        varPattern = varPattern.WithPrefix(VisitSpace(varPattern.Prefix, CsSpace.Location.VAR_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(varPattern, p);
        if (tempExpression is not Cs.VarPattern)
        {
            return tempExpression;
        }
        varPattern = (Cs.VarPattern) tempExpression;
        varPattern = varPattern.WithMarkers(VisitMarkers(varPattern.Markers, p));
        varPattern = varPattern.WithDesignation(VisitAndCast<Cs.VariableDesignation>(varPattern.Designation, p)!);
        return varPattern;
    }

    public virtual J? VisitPositionalPatternClause(Cs.PositionalPatternClause positionalPatternClause, P p)
    {
        positionalPatternClause = positionalPatternClause.WithPrefix(VisitSpace(positionalPatternClause.Prefix, CsSpace.Location.POSITIONAL_PATTERN_CLAUSE_PREFIX, p)!);
        positionalPatternClause = positionalPatternClause.WithMarkers(VisitMarkers(positionalPatternClause.Markers, p));
        positionalPatternClause = positionalPatternClause.Padding.WithSubpatterns(VisitContainer(positionalPatternClause.Padding.Subpatterns, CsContainer.Location.POSITIONAL_PATTERN_CLAUSE_SUBPATTERNS, p)!);
        return positionalPatternClause;
    }

    public virtual J? VisitRelationalPattern(Cs.RelationalPattern relationalPattern, P p)
    {
        relationalPattern = relationalPattern.WithPrefix(VisitSpace(relationalPattern.Prefix, CsSpace.Location.RELATIONAL_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(relationalPattern, p);
        if (tempExpression is not Cs.RelationalPattern)
        {
            return tempExpression;
        }
        relationalPattern = (Cs.RelationalPattern) tempExpression;
        relationalPattern = relationalPattern.WithMarkers(VisitMarkers(relationalPattern.Markers, p));
        relationalPattern = relationalPattern.Padding.WithOperator(VisitLeftPadded(relationalPattern.Padding.Operator, CsLeftPadded.Location.RELATIONAL_PATTERN_OPERATOR, p)!);
        relationalPattern = relationalPattern.WithValue(VisitAndCast<Expression>(relationalPattern.Value, p)!);
        return relationalPattern;
    }

    public virtual J? VisitSlicePattern(Cs.SlicePattern slicePattern, P p)
    {
        slicePattern = slicePattern.WithPrefix(VisitSpace(slicePattern.Prefix, CsSpace.Location.SLICE_PATTERN_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(slicePattern, p);
        if (tempExpression is not Cs.SlicePattern)
        {
            return tempExpression;
        }
        slicePattern = (Cs.SlicePattern) tempExpression;
        slicePattern = slicePattern.WithMarkers(VisitMarkers(slicePattern.Markers, p));
        return slicePattern;
    }

    public virtual J? VisitPropertyPatternClause(Cs.PropertyPatternClause propertyPatternClause, P p)
    {
        propertyPatternClause = propertyPatternClause.WithPrefix(VisitSpace(propertyPatternClause.Prefix, CsSpace.Location.PROPERTY_PATTERN_CLAUSE_PREFIX, p)!);
        propertyPatternClause = propertyPatternClause.WithMarkers(VisitMarkers(propertyPatternClause.Markers, p));
        propertyPatternClause = propertyPatternClause.Padding.WithSubpatterns(VisitContainer(propertyPatternClause.Padding.Subpatterns, CsContainer.Location.PROPERTY_PATTERN_CLAUSE_SUBPATTERNS, p)!);
        return propertyPatternClause;
    }

    public virtual J? VisitSubpattern(Cs.Subpattern subpattern, P p)
    {
        subpattern = subpattern.WithPrefix(VisitSpace(subpattern.Prefix, CsSpace.Location.SUBPATTERN_PREFIX, p)!);
        subpattern = subpattern.WithMarkers(VisitMarkers(subpattern.Markers, p));
        subpattern = subpattern.WithName(VisitAndCast<J.Identifier>(subpattern.Name, p));
        subpattern = subpattern.Padding.WithPattern(VisitLeftPadded(subpattern.Padding.Pattern, CsLeftPadded.Location.SUBPATTERN_PATTERN, p)!);
        return subpattern;
    }

    public virtual J? VisitSwitchExpression(Cs.SwitchExpression switchExpression, P p)
    {
        switchExpression = switchExpression.WithPrefix(VisitSpace(switchExpression.Prefix, CsSpace.Location.SWITCH_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(switchExpression, p);
        if (tempExpression is not Cs.SwitchExpression)
        {
            return tempExpression;
        }
        switchExpression = (Cs.SwitchExpression) tempExpression;
        switchExpression = switchExpression.WithMarkers(VisitMarkers(switchExpression.Markers, p));
        switchExpression = switchExpression.Padding.WithExpression(VisitRightPadded(switchExpression.Padding.Expression, CsRightPadded.Location.SWITCH_EXPRESSION_EXPRESSION, p)!);
        switchExpression = switchExpression.Padding.WithArms(VisitContainer(switchExpression.Padding.Arms, CsContainer.Location.SWITCH_EXPRESSION_ARMS, p)!);
        return switchExpression;
    }

    public virtual J? VisitSwitchExpressionArm(Cs.SwitchExpressionArm switchExpressionArm, P p)
    {
        switchExpressionArm = switchExpressionArm.WithPrefix(VisitSpace(switchExpressionArm.Prefix, CsSpace.Location.SWITCH_EXPRESSION_ARM_PREFIX, p)!);
        switchExpressionArm = switchExpressionArm.WithMarkers(VisitMarkers(switchExpressionArm.Markers, p));
        switchExpressionArm = switchExpressionArm.WithPattern(VisitAndCast<Cs.Pattern>(switchExpressionArm.Pattern, p)!);
        switchExpressionArm = switchExpressionArm.Padding.WithWhenExpression(switchExpressionArm.Padding.WhenExpression == null ? null : VisitLeftPadded(switchExpressionArm.Padding.WhenExpression, CsLeftPadded.Location.SWITCH_EXPRESSION_ARM_WHEN_EXPRESSION, p));
        switchExpressionArm = switchExpressionArm.Padding.WithExpression(VisitLeftPadded(switchExpressionArm.Padding.Expression, CsLeftPadded.Location.SWITCH_EXPRESSION_ARM_EXPRESSION, p)!);
        return switchExpressionArm;
    }

    public virtual J? VisitSwitchSection(Cs.SwitchSection switchSection, P p)
    {
        switchSection = switchSection.WithPrefix(VisitSpace(switchSection.Prefix, CsSpace.Location.SWITCH_SECTION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(switchSection, p);
        if (tempStatement is not Cs.SwitchSection)
        {
            return tempStatement;
        }
        switchSection = (Cs.SwitchSection) tempStatement;
        switchSection = switchSection.WithMarkers(VisitMarkers(switchSection.Markers, p));
        switchSection = switchSection.WithLabels(switchSection.Labels.Map(el => (Cs.SwitchLabel?)Visit(el, p)));
        switchSection = switchSection.Padding.WithStatements(switchSection.Padding.Statements.Map(el => VisitRightPadded(el, CsRightPadded.Location.SWITCH_SECTION_STATEMENTS, p)));
        return switchSection;
    }

    public virtual J? VisitDefaultSwitchLabel(Cs.DefaultSwitchLabel defaultSwitchLabel, P p)
    {
        defaultSwitchLabel = defaultSwitchLabel.WithPrefix(VisitSpace(defaultSwitchLabel.Prefix, CsSpace.Location.DEFAULT_SWITCH_LABEL_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(defaultSwitchLabel, p);
        if (tempExpression is not Cs.DefaultSwitchLabel)
        {
            return tempExpression;
        }
        defaultSwitchLabel = (Cs.DefaultSwitchLabel) tempExpression;
        defaultSwitchLabel = defaultSwitchLabel.WithMarkers(VisitMarkers(defaultSwitchLabel.Markers, p));
        defaultSwitchLabel = defaultSwitchLabel.WithColonToken(VisitSpace(defaultSwitchLabel.ColonToken, CsSpace.Location.DEFAULT_SWITCH_LABEL_COLON_TOKEN, p)!);
        return defaultSwitchLabel;
    }

    public virtual J? VisitCasePatternSwitchLabel(Cs.CasePatternSwitchLabel casePatternSwitchLabel, P p)
    {
        casePatternSwitchLabel = casePatternSwitchLabel.WithPrefix(VisitSpace(casePatternSwitchLabel.Prefix, CsSpace.Location.CASE_PATTERN_SWITCH_LABEL_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(casePatternSwitchLabel, p);
        if (tempExpression is not Cs.CasePatternSwitchLabel)
        {
            return tempExpression;
        }
        casePatternSwitchLabel = (Cs.CasePatternSwitchLabel) tempExpression;
        casePatternSwitchLabel = casePatternSwitchLabel.WithMarkers(VisitMarkers(casePatternSwitchLabel.Markers, p));
        casePatternSwitchLabel = casePatternSwitchLabel.WithPattern(VisitAndCast<Cs.Pattern>(casePatternSwitchLabel.Pattern, p)!);
        casePatternSwitchLabel = casePatternSwitchLabel.Padding.WithWhenClause(casePatternSwitchLabel.Padding.WhenClause == null ? null : VisitLeftPadded(casePatternSwitchLabel.Padding.WhenClause, CsLeftPadded.Location.CASE_PATTERN_SWITCH_LABEL_WHEN_CLAUSE, p));
        casePatternSwitchLabel = casePatternSwitchLabel.WithColonToken(VisitSpace(casePatternSwitchLabel.ColonToken, CsSpace.Location.CASE_PATTERN_SWITCH_LABEL_COLON_TOKEN, p)!);
        return casePatternSwitchLabel;
    }

    public virtual J? VisitSwitchStatement(Cs.SwitchStatement switchStatement, P p)
    {
        switchStatement = switchStatement.WithPrefix(VisitSpace(switchStatement.Prefix, CsSpace.Location.SWITCH_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(switchStatement, p);
        if (tempStatement is not Cs.SwitchStatement)
        {
            return tempStatement;
        }
        switchStatement = (Cs.SwitchStatement) tempStatement;
        switchStatement = switchStatement.WithMarkers(VisitMarkers(switchStatement.Markers, p));
        switchStatement = switchStatement.Padding.WithExpression(VisitContainer(switchStatement.Padding.Expression, CsContainer.Location.SWITCH_STATEMENT_EXPRESSION, p)!);
        switchStatement = switchStatement.Padding.WithSections(VisitContainer(switchStatement.Padding.Sections, CsContainer.Location.SWITCH_STATEMENT_SECTIONS, p)!);
        return switchStatement;
    }

    public virtual J? VisitLockStatement(Cs.LockStatement lockStatement, P p)
    {
        lockStatement = lockStatement.WithPrefix(VisitSpace(lockStatement.Prefix, CsSpace.Location.LOCK_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(lockStatement, p);
        if (tempStatement is not Cs.LockStatement)
        {
            return tempStatement;
        }
        lockStatement = (Cs.LockStatement) tempStatement;
        lockStatement = lockStatement.WithMarkers(VisitMarkers(lockStatement.Markers, p));
        lockStatement = lockStatement.WithExpression(VisitAndCast<J.ControlParentheses<Expression>>(lockStatement.Expression, p)!);
        lockStatement = lockStatement.Padding.WithStatement(VisitRightPadded(lockStatement.Padding.Statement, CsRightPadded.Location.LOCK_STATEMENT_STATEMENT, p)!);
        return lockStatement;
    }

    public virtual J? VisitFixedStatement(Cs.FixedStatement fixedStatement, P p)
    {
        fixedStatement = fixedStatement.WithPrefix(VisitSpace(fixedStatement.Prefix, CsSpace.Location.FIXED_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(fixedStatement, p);
        if (tempStatement is not Cs.FixedStatement)
        {
            return tempStatement;
        }
        fixedStatement = (Cs.FixedStatement) tempStatement;
        fixedStatement = fixedStatement.WithMarkers(VisitMarkers(fixedStatement.Markers, p));
        fixedStatement = fixedStatement.WithDeclarations(VisitAndCast<J.ControlParentheses<J.VariableDeclarations>>(fixedStatement.Declarations, p)!);
        fixedStatement = fixedStatement.WithBlock(VisitAndCast<J.Block>(fixedStatement.Block, p)!);
        return fixedStatement;
    }

    public virtual J? VisitCheckedStatement(Cs.CheckedStatement checkedStatement, P p)
    {
        checkedStatement = checkedStatement.WithPrefix(VisitSpace(checkedStatement.Prefix, CsSpace.Location.CHECKED_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(checkedStatement, p);
        if (tempStatement is not Cs.CheckedStatement)
        {
            return tempStatement;
        }
        checkedStatement = (Cs.CheckedStatement) tempStatement;
        checkedStatement = checkedStatement.WithMarkers(VisitMarkers(checkedStatement.Markers, p));
        checkedStatement = checkedStatement.WithBlock(VisitAndCast<J.Block>(checkedStatement.Block, p)!);
        return checkedStatement;
    }

    public virtual J? VisitUnsafeStatement(Cs.UnsafeStatement unsafeStatement, P p)
    {
        unsafeStatement = unsafeStatement.WithPrefix(VisitSpace(unsafeStatement.Prefix, CsSpace.Location.UNSAFE_STATEMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(unsafeStatement, p);
        if (tempStatement is not Cs.UnsafeStatement)
        {
            return tempStatement;
        }
        unsafeStatement = (Cs.UnsafeStatement) tempStatement;
        unsafeStatement = unsafeStatement.WithMarkers(VisitMarkers(unsafeStatement.Markers, p));
        unsafeStatement = unsafeStatement.WithBlock(VisitAndCast<J.Block>(unsafeStatement.Block, p)!);
        return unsafeStatement;
    }

    public virtual J? VisitRangeExpression(Cs.RangeExpression rangeExpression, P p)
    {
        rangeExpression = rangeExpression.WithPrefix(VisitSpace(rangeExpression.Prefix, CsSpace.Location.RANGE_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(rangeExpression, p);
        if (tempExpression is not Cs.RangeExpression)
        {
            return tempExpression;
        }
        rangeExpression = (Cs.RangeExpression) tempExpression;
        rangeExpression = rangeExpression.WithMarkers(VisitMarkers(rangeExpression.Markers, p));
        rangeExpression = rangeExpression.Padding.WithStart(rangeExpression.Padding.Start == null ? null : VisitRightPadded(rangeExpression.Padding.Start, CsRightPadded.Location.RANGE_EXPRESSION_START, p));
        rangeExpression = rangeExpression.WithEnd(VisitAndCast<Expression>(rangeExpression.End, p));
        return rangeExpression;
    }

    protected virtual JContainer<J2>? VisitContainer<J2>(JContainer<J2>? container, CsContainer.Location loc, P p) where J2 : J
    {
        if (container == null) {
            return null;
        }

        Cursor = new Cursor(Cursor, container);

        var before = VisitSpace(container.Before, loc.BeforeLocation, p);
        var js = ListUtils.Map(container.Padding.Elements, t => VisitRightPadded(t, loc.ElementLocation, p));

        Cursor = Cursor.Parent!;

        return js == container.Padding.Elements && before == container.Before ?
            container :
            JContainer<J2>.Build(before!, js, container.Markers);
    }

    protected virtual JLeftPadded<J2>? VisitLeftPadded<J2>(JLeftPadded<J2>? left, CsLeftPadded.Location loc, P p)
    {
        if (left == null)
        {
            return null;
        }

        Cursor = new Cursor(Cursor, left);

        var before = VisitSpace(left.Before, loc.BeforeLocation, p)!;
        var t = left.Element;
        if (t is Core.Tree)
        {
            t = (J2?)Visit((Core.Tree)t, p);
        }
        Cursor = Cursor.Parent!;

        // If nothing changed leave AST node the same
        if (ReferenceEquals(left.Element, t) && before == left.Before) {
            return left;
        }

        return t == null ? null : new JLeftPadded<J2>(before, t, left.Markers);
    }

    protected virtual JRightPadded<J2>? VisitRightPadded<J2>(JRightPadded<J2>? right, CsRightPadded.Location loc, P p)
    {
        if (right == null)
        {
            return null;
        }

        var t = right.Element;
        if (t is J)
        {
            Cursor = new Cursor(Cursor, right);
            t = (J2?)Visit((J)t, p);
            Cursor = Cursor.Parent!;
        }

        if (t == null)
        {
            return null;
        }

        right = right.WithElement(t);
        right = right.WithAfter(VisitSpace(right.After, loc.AfterLocation, p));
        right = right.WithMarkers(VisitMarkers(right.Markers, p));
        return right;
    }

    protected virtual Space VisitSpace(Space space, CsSpace.Location loc, P p)
    {
        return VisitSpace(space, Space.Location.LANGUAGE_EXTENSION, p);
    }
}
