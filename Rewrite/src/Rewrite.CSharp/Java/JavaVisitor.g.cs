//------------------------------------------------------------------------------
// <auto-generated>
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
#pragma warning disable CS0108 // 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable CS8767 // Nullability of reference types in type of parameter doesn't match implicitly implemented member (possibly because of nullability attributes).
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using Rewrite.Core;
using Rewrite.RewriteJava.Tree;

namespace Rewrite.RewriteJava;

[SuppressMessage("ReSharper", "InconsistentNaming")]
[SuppressMessage("ReSharper", "ReturnTypeCanBeNotNullable")]
[SuppressMessage("ReSharper", "MergeCastWithTypeCheck")]
public class JavaVisitor<P> : TreeVisitor<J, P>
{
    public override bool IsAcceptable(SourceFile sourceFile, P p)
    {
        return sourceFile is J;
    }

    public virtual J VisitExpression(Expression expression, P p) {
        return expression;
    }

    public virtual J VisitStatement(Statement statement, P p) {
        return statement;
    }

    public virtual J? VisitAnnotatedType(J.AnnotatedType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ANNOTATED_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.AnnotatedType)
        {
            return tempExpression;
        }
        node = (J.AnnotatedType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p)!);
        return node;
    }

    public virtual J? VisitAnnotation(J.Annotation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ANNOTATION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Annotation)
        {
            return tempExpression;
        }
        node = (J.Annotation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotationType(VisitAndCast<NameTree>(node.AnnotationType, p)!);
        node = node.Padding.WithArguments(node.Padding.Arguments == null ? null : VisitContainer(node.Padding.Arguments, JContainer.Location.ANNOTATION_ARGUMENTS, p));
        return node;
    }

    public virtual J? VisitArrayAccess(J.ArrayAccess node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ARRAY_ACCESS_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.ArrayAccess)
        {
            return tempExpression;
        }
        node = (J.ArrayAccess) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithIndexed(VisitAndCast<Expression>(node.Indexed, p)!);
        node = node.WithDimension(VisitAndCast<J.ArrayDimension>(node.Dimension, p)!);
        return node;
    }

    public virtual J? VisitArrayType(J.ArrayType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ARRAY_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.ArrayType)
        {
            return tempExpression;
        }
        node = (J.ArrayType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithElementType(VisitAndCast<TypeTree>(node.ElementType, p)!);
        node = node.WithAnnotations(node.Annotations?.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithDimension(node.Dimension.WithBefore(VisitSpace(node.Dimension.Before, Space.Location.DIMENSION_PREFIX, p)).WithElement(VisitSpace(node.Dimension.Element, Space.Location.DIMENSION, p)));
        return node;
    }

    public virtual J? VisitAssert(J.Assert node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ASSERT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Assert)
        {
            return tempStatement;
        }
        node = (J.Assert) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithCondition(VisitAndCast<Expression>(node.Condition, p)!);
        node = node.WithDetail(node.Detail == null ? null : VisitLeftPadded(node.Detail, JLeftPadded.Location.ASSERT_DETAIL, p));
        return node;
    }

    public virtual J? VisitAssignment(J.Assignment node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ASSIGNMENT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Assignment)
        {
            return tempStatement;
        }
        node = (J.Assignment) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Assignment)
        {
            return tempExpression;
        }
        node = (J.Assignment) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithVariable(VisitAndCast<Expression>(node.Variable, p)!);
        node = node.Padding.WithExpression(VisitLeftPadded(node.Padding.Expression, JLeftPadded.Location.ASSIGNMENT, p)!);
        return node;
    }

    public virtual J? VisitAssignmentOperation(J.AssignmentOperation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ASSIGNMENT_OPERATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.AssignmentOperation)
        {
            return tempStatement;
        }
        node = (J.AssignmentOperation) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.AssignmentOperation)
        {
            return tempExpression;
        }
        node = (J.AssignmentOperation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithVariable(VisitAndCast<Expression>(node.Variable, p)!);
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.ASSIGNMENT_OPERATION_OPERATOR, p)!);
        node = node.WithAssignment(VisitAndCast<Expression>(node.Assignment, p)!);
        return node;
    }

    public virtual J? VisitBinary(J.Binary node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.BINARY_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Binary)
        {
            return tempExpression;
        }
        node = (J.Binary) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLeft(VisitAndCast<Expression>(node.Left, p)!);
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.BINARY_OPERATOR, p)!);
        node = node.WithRight(VisitAndCast<Expression>(node.Right, p)!);
        return node;
    }

    public virtual J? VisitBlock(J.Block node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.BLOCK_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Block)
        {
            return tempStatement;
        }
        node = (J.Block) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithStatic(VisitRightPadded(node.Padding.Static, JRightPadded.Location.STATIC_INIT, p)!);
        node = node.Padding.WithStatements(node.Padding.Statements.Map(el => VisitRightPadded(el, JRightPadded.Location.BLOCK_STATEMENT, p)));
        node = node.WithEnd(VisitSpace(node.End, Space.Location.BLOCK_END, p)!);
        return node;
    }

    public virtual J? VisitBreak(J.Break node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.BREAK_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Break)
        {
            return tempStatement;
        }
        node = (J.Break) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLabel(VisitAndCast<J.Identifier>(node.Label, p));
        return node;
    }

    public virtual J? VisitCase(J.Case node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CASE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Case)
        {
            return tempStatement;
        }
        node = (J.Case) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithCaseLabels(VisitContainer(node.Padding.CaseLabels, JContainer.Location.CASE_CASE_LABELS, p)!);
        node = node.Padding.WithStatements(VisitContainer(node.Padding.Statements, JContainer.Location.CASE, p)!);
        node = node.Padding.WithBody(node.Padding.Body == null ? null : VisitRightPadded(node.Padding.Body, JRightPadded.Location.CASE_BODY, p));
        node = node.WithGuard(VisitAndCast<Expression>(node.Guard, p));
        return node;
    }

    public virtual J? VisitClassDeclaration(J.ClassDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CLASS_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.ClassDeclaration)
        {
            return tempStatement;
        }
        node = (J.ClassDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLeadingAnnotations(node.LeadingAnnotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Padding.WithDeclarationKind(VisitAndCast<J.ClassDeclaration.Kind>(node.Padding.DeclarationKind, p)!);
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.TYPE_PARAMETERS, p));
        node = node.Padding.WithPrimaryConstructor(node.Padding.PrimaryConstructor == null ? null : VisitContainer(node.Padding.PrimaryConstructor, JContainer.Location.RECORD_STATE_VECTOR, p));
        node = node.Padding.WithExtends(node.Padding.Extends == null ? null : VisitLeftPadded(node.Padding.Extends, JLeftPadded.Location.EXTENDS, p));
        node = node.Padding.WithImplements(node.Padding.Implements == null ? null : VisitContainer(node.Padding.Implements, JContainer.Location.IMPLEMENTS, p));
        node = node.Padding.WithPermits(node.Padding.Permits == null ? null : VisitContainer(node.Padding.Permits, JContainer.Location.PERMITS, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitClassDeclarationKind(J.ClassDeclaration.Kind node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CLASS_KIND, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        return node;
    }

    public virtual J? VisitCompilationUnit(J.CompilationUnit node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.COMPILATION_UNIT_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithPackageDeclaration(node.Padding.PackageDeclaration == null ? null : VisitRightPadded(node.Padding.PackageDeclaration, JRightPadded.Location.PACKAGE, p));
        node = node.Padding.WithImports(node.Padding.Imports.Map(el => VisitRightPadded(el, JRightPadded.Location.IMPORT, p)));
        node = node.WithClasses(node.Classes.Map(el => (J.ClassDeclaration?)Visit(el, p)));
        node = node.WithEof(VisitSpace(node.Eof, Space.Location.COMPILATION_UNIT_EOF, p)!);
        return node;
    }

    public virtual J? VisitContinue(J.Continue node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONTINUE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Continue)
        {
            return tempStatement;
        }
        node = (J.Continue) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLabel(VisitAndCast<J.Identifier>(node.Label, p));
        return node;
    }

    public virtual J? VisitDoWhileLoop(J.DoWhileLoop node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DO_WHILE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.DoWhileLoop)
        {
            return tempStatement;
        }
        node = (J.DoWhileLoop) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithBody(VisitRightPadded(node.Padding.Body, JRightPadded.Location.WHILE_BODY, p)!);
        node = node.Padding.WithWhileCondition(VisitLeftPadded(node.Padding.WhileCondition, JLeftPadded.Location.WHILE_CONDITION, p)!);
        return node;
    }

    public virtual J? VisitEmpty(J.Empty node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.EMPTY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Empty)
        {
            return tempStatement;
        }
        node = (J.Empty) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Empty)
        {
            return tempExpression;
        }
        node = (J.Empty) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitEnumValue(J.EnumValue node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ENUM_VALUE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.WithInitializer(VisitAndCast<J.NewClass>(node.Initializer, p));
        return node;
    }

    public virtual J? VisitEnumValueSet(J.EnumValueSet node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ENUM_VALUE_SET_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.EnumValueSet)
        {
            return tempStatement;
        }
        node = (J.EnumValueSet) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithEnums(node.Padding.Enums.Map(el => VisitRightPadded(el, JRightPadded.Location.ENUM_VALUE, p)));
        return node;
    }

    public virtual J? VisitFieldAccess(J.FieldAccess node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FIELD_ACCESS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.FieldAccess)
        {
            return tempStatement;
        }
        node = (J.FieldAccess) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.FieldAccess)
        {
            return tempExpression;
        }
        node = (J.FieldAccess) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTarget(VisitAndCast<Expression>(node.Target, p)!);
        node = node.Padding.WithName(VisitLeftPadded(node.Padding.Name, JLeftPadded.Location.FIELD_ACCESS_NAME, p)!);
        return node;
    }

    public virtual J? VisitForEachLoop(J.ForEachLoop node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FOR_EACH_LOOP_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.ForEachLoop)
        {
            return tempStatement;
        }
        node = (J.ForEachLoop) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLoopControl(VisitAndCast<J.ForEachLoop.Control>(node.LoopControl, p)!);
        node = node.Padding.WithBody(VisitRightPadded(node.Padding.Body, JRightPadded.Location.FOR_BODY, p)!);
        return node;
    }

    public virtual J? VisitForEachControl(J.ForEachLoop.Control node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FOR_EACH_CONTROL_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithVariable(VisitRightPadded(node.Padding.Variable, JRightPadded.Location.FOREACH_VARIABLE, p)!);
        node = node.Padding.WithIterable(VisitRightPadded(node.Padding.Iterable, JRightPadded.Location.FOREACH_ITERABLE, p)!);
        return node;
    }

    public virtual J? VisitForLoop(J.ForLoop node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FOR_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.ForLoop)
        {
            return tempStatement;
        }
        node = (J.ForLoop) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLoopControl(VisitAndCast<J.ForLoop.Control>(node.LoopControl, p)!);
        node = node.Padding.WithBody(VisitRightPadded(node.Padding.Body, JRightPadded.Location.FOR_BODY, p)!);
        return node;
    }

    public virtual J? VisitForControl(J.ForLoop.Control node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.FOR_CONTROL_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithInit(node.Padding.Init.Map(el => VisitRightPadded(el, JRightPadded.Location.FOR_INIT, p)));
        node = node.Padding.WithCondition(VisitRightPadded(node.Padding.Condition, JRightPadded.Location.FOR_CONDITION, p)!);
        node = node.Padding.WithUpdate(node.Padding.Update.Map(el => VisitRightPadded(el, JRightPadded.Location.FOR_UPDATE, p)));
        return node;
    }

    public virtual J? VisitParenthesizedTypeTree(J.ParenthesizedTypeTree node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PARENTHESES_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.ParenthesizedTypeTree)
        {
            return tempExpression;
        }
        node = (J.ParenthesizedTypeTree) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithParenthesizedType(VisitAndCast<J.Parentheses<TypeTree>>(node.ParenthesizedType, p)!);
        return node;
    }

    public virtual J? VisitIdentifier(J.Identifier node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.IDENTIFIER_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Identifier)
        {
            return tempExpression;
        }
        node = (J.Identifier) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        return node;
    }

    public virtual J? VisitIf(J.If node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.IF_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.If)
        {
            return tempStatement;
        }
        node = (J.If) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithIfCondition(VisitAndCast<J.ControlParentheses<Expression>>(node.IfCondition, p)!);
        node = node.Padding.WithThenPart(VisitRightPadded(node.Padding.ThenPart, JRightPadded.Location.IF_THEN, p)!);
        node = node.WithElsePart(VisitAndCast<J.If.Else>(node.ElsePart, p));
        return node;
    }

    public virtual J? VisitElse(J.If.Else node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ELSE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithBody(VisitRightPadded(node.Padding.Body, JRightPadded.Location.IF_ELSE, p)!);
        return node;
    }

    public virtual J? VisitImport(J.Import node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.IMPORT_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Import)
        {
            return tempStatement;
        }
        node = (J.Import) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithStatic(VisitLeftPadded(node.Padding.Static, JLeftPadded.Location.STATIC_IMPORT, p)!);
        node = node.WithQualid(VisitAndCast<J.FieldAccess>(node.Qualid, p)!);
        node = node.Padding.WithAlias(node.Padding.Alias == null ? null : VisitLeftPadded(node.Padding.Alias, JLeftPadded.Location.IMPORT_ALIAS_PREFIX, p));
        return node;
    }

    public virtual J? VisitInstanceOf(J.InstanceOf node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.INSTANCEOF_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.InstanceOf)
        {
            return tempExpression;
        }
        node = (J.InstanceOf) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithExpression(VisitRightPadded(node.Padding.Expression, JRightPadded.Location.INSTANCEOF, p)!);
        node = node.WithClazz(VisitAndCast<J>(node.Clazz, p)!);
        node = node.WithPattern(VisitAndCast<J>(node.Pattern, p));
        node = node.WithModifier(VisitAndCast<J.Modifier>(node.Modifier, p));
        return node;
    }

    public virtual J? VisitDeconstructionPattern(J.DeconstructionPattern node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DECONSTRUCTION_PATTERN_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithDeconstructor(VisitAndCast<Expression>(node.Deconstructor, p)!);
        node = node.Padding.WithNested(VisitContainer(node.Padding.Nested, JContainer.Location.DECONSTRUCTION_PATTERN_NESTED, p)!);
        return node;
    }

    public virtual J? VisitIntersectionType(J.IntersectionType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.INTERSECTION_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.IntersectionType)
        {
            return tempExpression;
        }
        node = (J.IntersectionType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithBounds(VisitContainer(node.Padding.Bounds, JContainer.Location.TYPE_BOUNDS, p)!);
        return node;
    }

    public virtual J? VisitLabel(J.Label node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LABEL_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Label)
        {
            return tempStatement;
        }
        node = (J.Label) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithName(VisitRightPadded(node.Padding.Name, JRightPadded.Location.LABEL, p)!);
        node = node.WithStatement(VisitAndCast<Statement>(node.Statement, p)!);
        return node;
    }

    public virtual J? VisitLambda(J.Lambda node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LAMBDA_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Lambda)
        {
            return tempStatement;
        }
        node = (J.Lambda) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Lambda)
        {
            return tempExpression;
        }
        node = (J.Lambda) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithParams(VisitAndCast<J.Lambda.Parameters>(node.Params, p)!);
        node = node.WithArrow(VisitSpace(node.Arrow, Space.Location.LAMBDA_ARROW_PREFIX, p)!);
        node = node.WithBody(VisitAndCast<J>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitLambdaParameters(J.Lambda.Parameters node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LAMBDA_PARAMETERS_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithElements(node.Padding.Elements.Map(el => VisitRightPadded(el, JRightPadded.Location.LAMBDA_PARAM, p)));
        return node;
    }

    public virtual J? VisitLiteral(J.Literal node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.LITERAL_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Literal)
        {
            return tempExpression;
        }
        node = (J.Literal) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitMemberReference(J.MemberReference node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.MEMBER_REFERENCE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.MemberReference)
        {
            return tempExpression;
        }
        node = (J.MemberReference) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithContaining(VisitRightPadded(node.Padding.Containing, JRightPadded.Location.MEMBER_REFERENCE_CONTAINING, p)!);
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.TYPE_PARAMETERS, p));
        node = node.Padding.WithReference(VisitLeftPadded(node.Padding.Reference, JLeftPadded.Location.MEMBER_REFERENCE_NAME, p)!);
        return node;
    }

    public virtual J? VisitMethodDeclaration(J.MethodDeclaration node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.METHOD_DECLARATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.MethodDeclaration)
        {
            return tempStatement;
        }
        node = (J.MethodDeclaration) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLeadingAnnotations(node.LeadingAnnotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.Annotations.WithTypeParameters(VisitAndCast<J.TypeParameters>(node.Annotations.TypeParameters, p));
        node = node.WithReturnTypeExpression(VisitAndCast<TypeTree>(node.ReturnTypeExpression, p));
        node = node.Annotations.WithName(node.Annotations.Name.WithAnnotations(ListUtils.Map(node.Annotations.Name.Annotations, el => (J.Annotation?)Visit(el, p))).WithIdentifier(VisitAndCast<J.Identifier>(node.Annotations.Name.Identifier, p)!));
        node = node.Padding.WithParameters(VisitContainer(node.Padding.Parameters, JContainer.Location.METHOD_DECLARATION_PARAMETERS, p)!);
        node = node.Padding.WithThrows(node.Padding.Throws == null ? null : VisitContainer(node.Padding.Throws, JContainer.Location.THROWS, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p));
        node = node.Padding.WithDefaultValue(node.Padding.DefaultValue == null ? null : VisitLeftPadded(node.Padding.DefaultValue, JLeftPadded.Location.METHOD_DECLARATION_DEFAULT_VALUE, p));
        return node;
    }

    public virtual J? VisitMethodInvocation(J.MethodInvocation node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.METHOD_INVOCATION_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.MethodInvocation)
        {
            return tempStatement;
        }
        node = (J.MethodInvocation) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.MethodInvocation)
        {
            return tempExpression;
        }
        node = (J.MethodInvocation) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithSelect(node.Padding.Select == null ? null : VisitRightPadded(node.Padding.Select, JRightPadded.Location.METHOD_SELECT, p));
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.TYPE_PARAMETERS, p));
        node = node.WithName(VisitAndCast<J.Identifier>(node.Name, p)!);
        node = node.Padding.WithArguments(VisitContainer(node.Padding.Arguments, JContainer.Location.METHOD_INVOCATION_ARGUMENTS, p)!);
        return node;
    }

    public virtual J? VisitModifier(J.Modifier node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.MODIFIER_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        return node;
    }

    public virtual J? VisitMultiCatch(J.MultiCatch node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.MULTI_CATCH_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithAlternatives(node.Padding.Alternatives.Map(el => VisitRightPadded(el, JRightPadded.Location.CATCH_ALTERNATIVE, p)));
        return node;
    }

    public virtual J? VisitNewArray(J.NewArray node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.NEW_ARRAY_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.NewArray)
        {
            return tempExpression;
        }
        node = (J.NewArray) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p));
        node = node.WithDimensions(node.Dimensions.Map(el => (J.ArrayDimension?)Visit(el, p)));
        node = node.Padding.WithInitializer(node.Padding.Initializer == null ? null : VisitContainer(node.Padding.Initializer, JContainer.Location.NEW_ARRAY_INITIALIZER, p));
        return node;
    }

    public virtual J? VisitArrayDimension(J.ArrayDimension node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.DIMENSION_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithIndex(VisitRightPadded(node.Padding.Index, JRightPadded.Location.ARRAY_INDEX, p)!);
        return node;
    }

    public virtual J? VisitNewClass(J.NewClass node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.NEW_CLASS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.NewClass)
        {
            return tempStatement;
        }
        node = (J.NewClass) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.NewClass)
        {
            return tempExpression;
        }
        node = (J.NewClass) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithEnclosing(node.Padding.Enclosing == null ? null : VisitRightPadded(node.Padding.Enclosing, JRightPadded.Location.NEW_CLASS_ENCLOSING, p));
        node = node.WithNew(VisitSpace(node.New, Space.Location.NEW_PREFIX, p)!);
        node = node.WithClazz(VisitAndCast<TypeTree>(node.Clazz, p));
        node = node.Padding.WithArguments(VisitContainer(node.Padding.Arguments, JContainer.Location.NEW_CLASS_ARGUMENTS, p)!);
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p));
        return node;
    }

    public virtual J? VisitNullableType(J.NullableType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.NULLABLE_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.NullableType)
        {
            return tempExpression;
        }
        node = (J.NullableType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.Padding.WithTypeTree(VisitRightPadded(node.Padding.TypeTree, JRightPadded.Location.NULLABLE, p)!);
        return node;
    }

    public virtual J? VisitPackage(J.Package node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PACKAGE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Package)
        {
            return tempStatement;
        }
        node = (J.Package) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        return node;
    }

    public virtual J? VisitParameterizedType(J.ParameterizedType node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PARAMETERIZED_TYPE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.ParameterizedType)
        {
            return tempExpression;
        }
        node = (J.ParameterizedType) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithClazz(VisitAndCast<NameTree>(node.Clazz, p)!);
        node = node.Padding.WithTypeParameters(node.Padding.TypeParameters == null ? null : VisitContainer(node.Padding.TypeParameters, JContainer.Location.TYPE_PARAMETERS, p));
        return node;
    }

    public virtual J? VisitParentheses<J2>(J.Parentheses<J2> node, P p) where J2 : J
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PARENTHESES_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Parentheses<J2>)
        {
            return tempExpression;
        }
        node = (J.Parentheses<J2>) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithTree(VisitRightPadded(node.Padding.Tree, JRightPadded.Location.PARENTHESES, p)!);
        return node;
    }

    public virtual J? VisitControlParentheses<J2>(J.ControlParentheses<J2> node, P p) where J2 : J
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CONTROL_PARENTHESES_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.ControlParentheses<J2>)
        {
            return tempExpression;
        }
        node = (J.ControlParentheses<J2>) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithTree(VisitRightPadded(node.Padding.Tree, JRightPadded.Location.PARENTHESES, p)!);
        return node;
    }

    public virtual J? VisitPrimitive(J.Primitive node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.PRIMITIVE_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Primitive)
        {
            return tempExpression;
        }
        node = (J.Primitive) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitReturn(J.Return node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.RETURN_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Return)
        {
            return tempStatement;
        }
        node = (J.Return) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p));
        return node;
    }

    public virtual J? VisitSwitch(J.Switch node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SWITCH_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Switch)
        {
            return tempStatement;
        }
        node = (J.Switch) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithSelector(VisitAndCast<J.ControlParentheses<Expression>>(node.Selector, p)!);
        node = node.WithCases(VisitAndCast<J.Block>(node.Cases, p)!);
        return node;
    }

    public virtual J? VisitSwitchExpression(J.SwitchExpression node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SWITCH_EXPRESSION_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.SwitchExpression)
        {
            return tempExpression;
        }
        node = (J.SwitchExpression) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithSelector(VisitAndCast<J.ControlParentheses<Expression>>(node.Selector, p)!);
        node = node.WithCases(VisitAndCast<J.Block>(node.Cases, p)!);
        return node;
    }

    public virtual J? VisitSynchronized(J.Synchronized node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.SYNCHRONIZED_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Synchronized)
        {
            return tempStatement;
        }
        node = (J.Synchronized) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLock(VisitAndCast<J.ControlParentheses<Expression>>(node.Lock, p)!);
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitTernary(J.Ternary node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TERNARY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Ternary)
        {
            return tempStatement;
        }
        node = (J.Ternary) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Ternary)
        {
            return tempExpression;
        }
        node = (J.Ternary) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithCondition(VisitAndCast<Expression>(node.Condition, p)!);
        node = node.Padding.WithTruePart(VisitLeftPadded(node.Padding.TruePart, JLeftPadded.Location.TERNARY_TRUE, p)!);
        node = node.Padding.WithFalsePart(VisitLeftPadded(node.Padding.FalsePart, JLeftPadded.Location.TERNARY_FALSE, p)!);
        return node;
    }

    public virtual J? VisitThrow(J.Throw node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.THROW_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Throw)
        {
            return tempStatement;
        }
        node = (J.Throw) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithException(VisitAndCast<Expression>(node.Exception, p)!);
        return node;
    }

    public virtual J? VisitTry(J.Try node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TRY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Try)
        {
            return tempStatement;
        }
        node = (J.Try) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithResources(node.Padding.Resources == null ? null : VisitContainer(node.Padding.Resources, JContainer.Location.TRY_RESOURCES, p));
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        node = node.WithCatches(node.Catches.Map(el => (J.Try.Catch?)Visit(el, p)));
        node = node.Padding.WithFinally(node.Padding.Finally == null ? null : VisitLeftPadded(node.Padding.Finally, JLeftPadded.Location.TRY_FINALLY, p));
        return node;
    }

    public virtual J? VisitTryResource(J.Try.Resource node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TRY_RESOURCE, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithVariableDeclarations(VisitAndCast<TypedTree>(node.VariableDeclarations, p)!);
        return node;
    }

    public virtual J? VisitCatch(J.Try.Catch node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.CATCH_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithParameter(VisitAndCast<J.ControlParentheses<J.VariableDeclarations>>(node.Parameter, p)!);
        node = node.WithBody(VisitAndCast<J.Block>(node.Body, p)!);
        return node;
    }

    public virtual J? VisitTypeCast(J.TypeCast node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_CAST_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.TypeCast)
        {
            return tempExpression;
        }
        node = (J.TypeCast) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithClazz(VisitAndCast<J.ControlParentheses<TypeTree>>(node.Clazz, p)!);
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitTypeParameter(J.TypeParameter node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_PARAMETERS_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.WithName(VisitAndCast<Expression>(node.Name, p)!);
        node = node.Padding.WithBounds(node.Padding.Bounds == null ? null : VisitContainer(node.Padding.Bounds, JContainer.Location.TYPE_BOUNDS, p));
        return node;
    }

    public virtual J? VisitTypeParameters(J.TypeParameters node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.TYPE_PARAMETERS_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithAnnotations(node.Annotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.Padding.WithParameters(node.Padding.Parameters.Map(el => VisitRightPadded(el, JRightPadded.Location.TYPE_PARAMETER, p)));
        return node;
    }

    public virtual J? VisitUnary(J.Unary node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.UNARY_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Unary)
        {
            return tempStatement;
        }
        node = (J.Unary) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Unary)
        {
            return tempExpression;
        }
        node = (J.Unary) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithOperator(VisitLeftPadded(node.Padding.Operator, JLeftPadded.Location.UNARY_OPERATOR, p)!);
        node = node.WithExpression(VisitAndCast<Expression>(node.Expression, p)!);
        return node;
    }

    public virtual J? VisitVariableDeclarations(J.VariableDeclarations node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.VARIABLE_DECLARATIONS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.VariableDeclarations)
        {
            return tempStatement;
        }
        node = (J.VariableDeclarations) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithLeadingAnnotations(node.LeadingAnnotations.Map(el => (J.Annotation?)Visit(el, p)));
        node = node.WithModifiers(node.Modifiers.Map(el => (J.Modifier?)Visit(el, p)));
        node = node.WithTypeExpression(VisitAndCast<TypeTree>(node.TypeExpression, p));
        node = node.WithVarargs(node.Varargs == null ? null : VisitSpace(node.Varargs, Space.Location.VARARGS, p));
        node = node.WithDimensionsBeforeName(ListUtils.Map(node.DimensionsBeforeName, el => el.WithBefore(VisitSpace(el.Before, Space.Location.DIMENSION_PREFIX, p)).WithElement(VisitSpace(el.Element, Space.Location.DIMENSION, p))));
        node = node.Padding.WithVariables(node.Padding.Variables.Map(el => VisitRightPadded(el, JRightPadded.Location.NAMED_VARIABLE, p)));
        return node;
    }

    public virtual J? VisitVariable(J.VariableDeclarations.NamedVariable node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.VARIABLE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithName(VisitAndCast<VariableDeclarator>(node.Name, p)!);
        node = node.WithDimensionsAfterName(ListUtils.Map(node.DimensionsAfterName, el => el.WithBefore(VisitSpace(el.Before, Space.Location.DIMENSION_PREFIX, p)).WithElement(VisitSpace(el.Element, Space.Location.DIMENSION, p))));
        node = node.Padding.WithInitializer(node.Padding.Initializer == null ? null : VisitLeftPadded(node.Padding.Initializer, JLeftPadded.Location.VARIABLE_INITIALIZER, p));
        return node;
    }

    public virtual J? VisitWhileLoop(J.WhileLoop node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.WHILE_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.WhileLoop)
        {
            return tempStatement;
        }
        node = (J.WhileLoop) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithCondition(VisitAndCast<J.ControlParentheses<Expression>>(node.Condition, p)!);
        node = node.Padding.WithBody(VisitRightPadded(node.Padding.Body, JRightPadded.Location.WHILE_BODY, p)!);
        return node;
    }

    public virtual J? VisitWildcard(J.Wildcard node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.WILDCARD_PREFIX, p)!);
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Wildcard)
        {
            return tempExpression;
        }
        node = (J.Wildcard) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.Padding.WithWildcardBound(node.Padding.WildcardBound == null ? null : VisitLeftPadded(node.Padding.WildcardBound, JLeftPadded.Location.WILDCARD_BOUND, p));
        node = node.WithBoundedType(VisitAndCast<NameTree>(node.BoundedType, p));
        return node;
    }

    public virtual J? VisitYield(J.Yield node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.YIELD_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Yield)
        {
            return tempStatement;
        }
        node = (J.Yield) tempStatement;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithValue(VisitAndCast<Expression>(node.Value, p)!);
        return node;
    }

    public virtual J? VisitUnknown(J.Unknown node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.UNKNOWN_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Unknown)
        {
            return tempStatement;
        }
        node = (J.Unknown) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Unknown)
        {
            return tempExpression;
        }
        node = (J.Unknown) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        node = node.WithUnknownSource(VisitAndCast<J.Unknown.Source>(node.UnknownSource, p)!);
        return node;
    }

    public virtual J? VisitUnknownSource(J.Unknown.Source node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.UNKNOWN_SOURCE_PREFIX, p)!);
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual J? VisitErroneous(J.Erroneous node, P p)
    {
        node = node.WithPrefix(VisitSpace(node.Prefix, Space.Location.ERRONEOUS_PREFIX, p)!);
        var tempStatement = (Statement) VisitStatement(node, p);
        if (tempStatement is not J.Erroneous)
        {
            return tempStatement;
        }
        node = (J.Erroneous) tempStatement;
        var tempExpression = (Expression) VisitExpression(node, p);
        if (tempExpression is not J.Erroneous)
        {
            return tempExpression;
        }
        node = (J.Erroneous) tempExpression;
        node = node.WithMarkers(VisitMarkers(node.Markers, p));
        return node;
    }

    public virtual JContainer<T>? VisitContainer<T>(JContainer<T>? container, JContainer.Location loc, P p)
    {
        if (container == null) {
            return null;
        }

        Cursor = new Cursor(Cursor, container);

        var before = VisitSpace(container.Before, loc.BeforeLocation, p);
        var js = ListUtils.Map(container.Padding.Elements, t => VisitRightPadded(t, loc.ElementLocation, p));

        Cursor = Cursor.Parent!;

        return js == container.Padding.Elements && before == container.Before ?
            container :
            JContainer<T>.Build(before!, js, container.Markers);
    }

    public virtual JLeftPadded<T>? VisitLeftPadded<T>(JLeftPadded<T>? left, JLeftPadded.Location loc, P p)
    {
        if (left == null)
        {
            return null;
        }

        Cursor = new Cursor(Cursor, left);

        var before = VisitSpace(left.Before, loc.BeforeLocation, p)!;
        var t = left.Element;
        if (left.Element is Core.Tree)
        {
            t = (T?)Visit(t as Core.Tree, p);
        }
        Cursor = Cursor.Parent!;

        // If nothing changed leave AST node the same
        if (ReferenceEquals(left.Element, t) && before == left.Before) {
            return left;
        }

        return t == null ? null : new JLeftPadded<T>(before, t, left.Markers);
    }

    public virtual JRightPadded<T>? VisitRightPadded<T>(JRightPadded<T>? right, JRightPadded.Location loc, P p)
    {
        if (right == null)
        {
            return null;
        }

        var t = right.Element;
        if (t is J)
        {
            Cursor = new Cursor(Cursor, right);
            t = (T?)Visit(t as J, p);
            Cursor = Cursor.Parent!;
        }

        if (t == null)
        {
            return null;
        }

        right = right.WithElement(t);
        right = right.WithAfter(VisitSpace(right.After, loc.AfterLocation, p) ?? Space.EMPTY);
        right = right.WithMarkers(VisitMarkers(right.Markers, p));
        return right;
    }

    public virtual Space VisitSpace(Space space, Space.Location? loc, P p)
    {
        // FIXME add Javadoc support
        return space;
    }

}
